This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-10T16:50:03.777Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
api/
  auth.dart
  detailed_orders.dart
  detailed_orders.g.dart
  kw_lemmas.dart
  kw_lemmas.g.dart
  lemmatize.dart
  lemmatize.g.dart
  normqueries.dart
  normqueries.g.dart
  orders.dart
  orders.g.dart
  products.dart
  products.g.dart
  promotions_api.dart
  stocks.dart
  stocks.g.dart
  subjects_summary.dart
  subjects_summary.g.dart
  suppliers_api_client.dart
  user_emails_api.dart
  user_search_queries_api.dart
  user_settings_api.dart
  user_skus_api.dart
  warehouses.dart
  warehouses.g.dart
repositories/
  api_key_storage.dart
  cookies.dart
  local_storage.dart
  mailing_settings_repo.dart
  saved_key_phrases_repo.dart
  saved_products_repo.dart
  user_email_repo.dart

================================================================
Files
================================================================

================
File: api/auth.dart
================
import 'dart:convert';

import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/services/auth_service.dart';
// ignore: depend_on_referenced_packages
import 'package:http/http.dart' as http;

class AuthApiClient implements AuthServiceAuthApiClient {
  const AuthApiClient();
  static const baseUrl = McAuthService.baseUrl;

  @override
  Future<Either<AppErrorBase, String>> register(
      String username, String password) async {
    try {
      final url = Uri.parse('$baseUrl/register');
      final response = await http.post(
        url,
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({'username': username, 'password': password}),
      );

      if (response.statusCode == 200) {
        final body = jsonDecode(response.body) as Map<String, dynamic>;
        final token = body['token'] as String?;
        if (token == null) {
          return left(AppErrorBase('Token not found in response',
              name: 'register', sendTo: true, source: 'AuthApiClient'));
        }
        return right(token);
      } else {
        return left(AppErrorBase('Status code: ${response.statusCode}',
            name: 'register', sendTo: true, source: 'AuthApiClient'));
      }
    } catch (e) {
      return left(AppErrorBase('Caught error: $e',
          name: 'register', sendTo: true, source: 'AuthApiClient'));
    }
  }

  @override
  Future<Either<AppErrorBase, String>> login(
      String username, String password) async {
    try {
      final url = Uri.parse('$baseUrl/login');
      final response = await http.post(
        url,
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({'username': username, 'password': password}),
      );

      if (response.statusCode == 200) {
        final body = jsonDecode(response.body) as Map<String, dynamic>;
        final token = body['token'] as String?;
        if (token == null) {
          return left(AppErrorBase('Token not found in response',
              name: 'login', sendTo: true, source: 'AuthApiClient'));
        }
        return right(token);
      } else {
        return left(AppErrorBase('Status code: ${response.statusCode}',
            name: 'login', sendTo: true, source: 'AuthApiClient'));
      }
    } catch (e) {
      return left(AppErrorBase('Caught error: $e',
          name: 'login', sendTo: true, source: 'AuthApiClient'));
    }
  }
}

================
File: api/detailed_orders.dart
================
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/entities/detailed_order_item.dart';

import 'package:retrofit/retrofit.dart';
import 'package:dio/dio.dart';

part 'detailed_orders.g.dart';

@RestApi(baseUrl: ApiSettings.baseUrl)
abstract class DetailedOrdersApiClient {
  factory DetailedOrdersApiClient(Dio dio, {String baseUrl}) =
      _DetailedOrdersApiClient;

  @GET("/detailed-orders30d")
  Future<DetailedOrdersResponse> getDetailedOrders({
    @Query("subject_id") int? subjectId,
    @Query("product_id") int? productId,
    @Query("is_fbs") int? isFbs,
    @Query("page_size") String? pageSize,
  });
}

class DetailedOrdersResponse {
  final List<DetailedOrderItem> detailedOrders;

  DetailedOrdersResponse({required this.detailedOrders});

  factory DetailedOrdersResponse.fromJson(Map<String, dynamic> json) {
    return DetailedOrdersResponse(
      detailedOrders: (json['detailed_orders30d'] as List)
          .map((item) => DetailedOrderItem.fromJson(item))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'detailed_orders30d':
          detailedOrders.map((item) => item.toJson()).toList(),
    };
  }
}

================
File: api/detailed_orders.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'detailed_orders.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _DetailedOrdersApiClient implements DetailedOrdersApiClient {
  _DetailedOrdersApiClient(
    this._dio, {
    this.baseUrl,
    this.errorLogger,
  }) {
    baseUrl ??= 'https://marketconnect.website/api';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<DetailedOrdersResponse> getDetailedOrders({
    int? subjectId,
    int? productId,
    int? isFbs,
    String? pageSize,
  }) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'subject_id': subjectId,
      r'product_id': productId,
      r'is_fbs': isFbs,
      r'page_size': pageSize,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<DetailedOrdersResponse>(Options(
      method: 'GET',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/detailed-orders30d',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late DetailedOrdersResponse _value;
    try {
      _value = DetailedOrdersResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(
    String dioBaseUrl,
    String? baseUrl,
  ) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

================
File: api/kw_lemmas.dart
================
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/entities/kw_lemmas.dart';
import 'package:retrofit/retrofit.dart';
import 'package:dio/dio.dart';

part 'kw_lemmas.g.dart';

@RestApi(baseUrl: ApiSettings.baseUrl)
abstract class KwLemmasApiClient {
  factory KwLemmasApiClient(Dio dio, {String baseUrl}) = _KwLemmasApiClient;

  @GET("/kw_lemmas")
  Future<KwLemmasResponse> getKwLemmas({
    @Query("ids") required List<int> ids,
  });
}

class KwLemmasResponse {
  final List<KwLemmaItem> kwLemmas;

  KwLemmasResponse({required this.kwLemmas});

  factory KwLemmasResponse.fromJson(Map<String, dynamic> json) {
    return KwLemmasResponse(
      kwLemmas: (json['kw_lemmas'] as List<dynamic>)
          .map((item) => KwLemmaItem.fromJson(item))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'kw_lemmas': kwLemmas.map((item) => item.toJson()).toList(),
    };
  }
}

================
File: api/kw_lemmas.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'kw_lemmas.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _KwLemmasApiClient implements KwLemmasApiClient {
  _KwLemmasApiClient(
    this._dio, {
    this.baseUrl,
    this.errorLogger,
  }) {
    baseUrl ??= 'https://marketconnect.website/api';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<KwLemmasResponse> getKwLemmas({required List<int> ids}) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'ids': ids};
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<KwLemmasResponse>(Options(
      method: 'GET',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/kw_lemmas',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late KwLemmasResponse _value;
    try {
      _value = KwLemmasResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(
    String dioBaseUrl,
    String? baseUrl,
  ) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

================
File: api/lemmatize.dart
================
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/entities/lemmatize.dart';
import 'package:retrofit/retrofit.dart';
import 'package:dio/dio.dart';

part 'lemmatize.g.dart';

@RestApi(baseUrl: ApiSettings.stemUrl)
abstract class LemmatizeApiClient {
  factory LemmatizeApiClient(Dio dio, {String baseUrl}) = _LemmatizeApiClient;

  @POST("/lemmatize")
  Future<LemmatizeResponse> lemmatize(@Body() LemmatizeRequest request);
}

================
File: api/lemmatize.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'lemmatize.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _LemmatizeApiClient implements LemmatizeApiClient {
  _LemmatizeApiClient(
    this._dio, {
    this.baseUrl,
    this.errorLogger,
  }) {
    baseUrl ??= 'https://marketconnect.website/stem/';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<LemmatizeResponse> lemmatize(LemmatizeRequest request) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{};
    final _headers = <String, dynamic>{};
    final _data = <String, dynamic>{};
    _data.addAll(request.toJson());
    final _options = _setStreamType<LemmatizeResponse>(Options(
      method: 'POST',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/lemmatize',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late LemmatizeResponse _value;
    try {
      _value = LemmatizeResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(
    String dioBaseUrl,
    String? baseUrl,
  ) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

================
File: api/normqueries.dart
================
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/entities/normquery.dart';
import 'package:mc_dashboard/domain/entities/normquery_product.dart';
import 'package:retrofit/retrofit.dart';
import 'package:dio/dio.dart';
part 'normqueries.g.dart';

@RestApi(baseUrl: ApiSettings.baseUrl)
abstract class NormqueriesApiClient {
  factory NormqueriesApiClient(Dio dio, {String baseUrl}) =
      _NormqueriesApiClient;

  @GET("/normqueries-products")
  Future<NormqueriesResponse> getNormqueriesProducts({
    @Query("ids") required List<int> ids,
  });

  @GET("/normqueries-unique")
  Future<UniqueNormqueriesResponse> getUniqueNormqueries({
    @Query("ids") required List<int> ids,
  });
}
// TODO Add token

class NormqueriesResponse {
  final List<NormqueryProduct> normqueriesWithProducts;

  NormqueriesResponse({
    required this.normqueriesWithProducts,
  });

  factory NormqueriesResponse.fromJson(Map<String, dynamic> json) {
    // Проверка, что поле `normquery_with_products` содержит список
    final products = json['normquery_with_products'];
    if (products is! List) {
      throw Exception(
          'Invalid format: "normquery_with_products" must be a List.');
    }

    // Преобразование списка объектов в `NormqueryProduct`
    return NormqueriesResponse(
      normqueriesWithProducts: products.map((item) {
        if (item is! Map<String, dynamic>) {
          throw Exception(
              'Invalid format: each item in "normquery_with_products" must be a Map<String, dynamic>.');
        }
        return NormqueryProduct.fromJson(item);
      }).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'normquery_with_products': normqueriesWithProducts
          .map((normqueryProduct) => normqueryProduct.toJson())
          .toList(),
    };
  }
}

class UniqueNormqueriesResponse {
  final List<Normquery> uniqueNormqueries;

  UniqueNormqueriesResponse({
    required this.uniqueNormqueries,
  });

  factory UniqueNormqueriesResponse.fromJson(Map<String, dynamic> json) {
    final queries = json['unique_normqueries'];
    if (queries is! List) {
      throw Exception('Invalid format: "unique_normqueries" must be a List.');
    }

    return UniqueNormqueriesResponse(
      uniqueNormqueries: queries.map((item) {
        if (item is! Map<String, dynamic>) {
          throw Exception(
              'Invalid format: each item in "unique_normqueries" must be a Map<String, dynamic>.');
        }
        return Normquery.fromJson(item);
      }).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'unique_normqueries':
          uniqueNormqueries.map((normquery) => normquery.toJson()).toList(),
    };
  }
}

================
File: api/normqueries.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'normqueries.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _NormqueriesApiClient implements NormqueriesApiClient {
  _NormqueriesApiClient(
    this._dio, {
    this.baseUrl,
    this.errorLogger,
  }) {
    baseUrl ??= 'https://marketconnect.website/api';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<NormqueriesResponse> getNormqueriesProducts(
      {required List<int> ids}) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'ids': ids};
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<NormqueriesResponse>(Options(
      method: 'GET',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/normqueries-products',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late NormqueriesResponse _value;
    try {
      _value = NormqueriesResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  @override
  Future<UniqueNormqueriesResponse> getUniqueNormqueries(
      {required List<int> ids}) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'ids': ids};
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<UniqueNormqueriesResponse>(Options(
      method: 'GET',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/normqueries-unique',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late UniqueNormqueriesResponse _value;
    try {
      _value = UniqueNormqueriesResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(
    String dioBaseUrl,
    String? baseUrl,
  ) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

================
File: api/orders.dart
================
import 'package:mc_dashboard/.env.dart';
import 'package:retrofit/retrofit.dart';
import 'package:dio/dio.dart';
import 'package:mc_dashboard/domain/entities/order.dart';
part 'orders.g.dart';
// TODO Add token
@RestApi(baseUrl: ApiSettings.baseUrl)
abstract class OrdersApiClient {
  factory OrdersApiClient(Dio dio, {String baseUrl}) = _OrdersApiClient;

  @GET("/orders")
  Future<OrdersResponse> getOrders({
    @Query("product_id") int? productId,
    @Query("warehouse_id") int? warehouseId,
    @Query("start_date") required String startDate,
    @Query("end_date") required String endDate,
    @Query("page") int? page,
    @Query("page_size") int? pageSize,
  });
}

class OrdersResponse {
  final List<OrderWb> orders;

  OrdersResponse({
    required this.orders,
  });

  factory OrdersResponse.fromJson(Map<String, dynamic> json) {
    return OrdersResponse(
      orders: (json['orders'] as List<dynamic>)
          .map((item) => OrderWb.fromJson(item as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'orders': orders.map((order) => order.toJson()).toList(),
    };
  }
}

================
File: api/orders.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'orders.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _OrdersApiClient implements OrdersApiClient {
  _OrdersApiClient(
    this._dio, {
    this.baseUrl,
    this.errorLogger,
  }) {
    baseUrl ??= 'https://marketconnect.website/api';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<OrdersResponse> getOrders({
    int? productId,
    int? warehouseId,
    required String startDate,
    required String endDate,
    int? page,
    int? pageSize,
  }) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'product_id': productId,
      r'warehouse_id': warehouseId,
      r'start_date': startDate,
      r'end_date': endDate,
      r'page': page,
      r'page_size': pageSize,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<OrdersResponse>(Options(
      method: 'GET',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/orders',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late OrdersResponse _value;
    try {
      _value = OrdersResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(
    String dioBaseUrl,
    String? baseUrl,
  ) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

================
File: api/products.dart
================
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/entities/product_item.dart';
import 'package:retrofit/retrofit.dart';
import 'package:dio/dio.dart';

part 'products.g.dart';

@RestApi(baseUrl: ApiSettings.baseUrl)
abstract class ProductsApiClient {
  factory ProductsApiClient(Dio dio, {String baseUrl}) = _ProductsApiClient;

  @GET("/products")
  Future<ProductsResponse> getProducts({
    @Query("brand_id") int? brandId,
    @Query("subject_id") int? subjectId,
    @Query("supplier_id") int? supplierId,
    @Query("page") int? page,
    @Query("page_size") int? pageSize,
  });
}

class ProductsResponse {
  final Pagination pagination;
  final List<ProductItem> products;

  ProductsResponse({
    required this.pagination,
    required this.products,
  });

  factory ProductsResponse.fromJson(Map<String, dynamic> json) {
    return ProductsResponse(
      pagination: Pagination.fromJson(json['pagination']),
      products: (json['products'] as List<dynamic>)
          .map((item) => ProductItem.fromJson(item as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'pagination': pagination.toJson(),
      'products': products.map((product) => product.toJson()).toList(),
    };
  }
}

class Pagination {
  final int currentPage;
  final int totalPages;
  final int pageSize;
  final int totalItems;

  Pagination({
    required this.currentPage,
    required this.totalPages,
    required this.pageSize,
    required this.totalItems,
  });

  factory Pagination.fromJson(Map<String, dynamic> json) {
    return Pagination(
      currentPage: json['current_page'] as int,
      totalPages: json['total_pages'] as int,
      pageSize: json['page_size'] as int,
      totalItems: json['total_items'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'current_page': currentPage,
      'total_pages': totalPages,
      'page_size': pageSize,
      'total_items': totalItems,
    };
  }
}

================
File: api/products.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'products.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _ProductsApiClient implements ProductsApiClient {
  _ProductsApiClient(
    this._dio, {
    this.baseUrl,
    this.errorLogger,
  }) {
    baseUrl ??= 'https://marketconnect.website/api';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<ProductsResponse> getProducts({
    int? brandId,
    int? subjectId,
    int? supplierId,
    int? page,
    int? pageSize,
  }) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'brand_id': brandId,
      r'subject_id': subjectId,
      r'supplier_id': supplierId,
      r'page': page,
      r'page_size': pageSize,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<ProductsResponse>(Options(
      method: 'GET',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/products',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late ProductsResponse _value;
    try {
      _value = ProductsResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(
    String dioBaseUrl,
    String? baseUrl,
  ) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

================
File: api/promotions_api.dart
================
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:mc_dashboard/domain/entities/promotions.dart';
import 'package:mc_dashboard/domain/services/promotion_service.dart';

class PromotionsApiClient implements PromotionsServiceApiClient {
  final String baseUrl;

  PromotionsApiClient(
      {this.baseUrl =
          "https://dp-calendar-api.wildberries.ru/api/v1/calendar"});

  @override
  Future<List<Promotion>> fetchPromotions({
    required String token,
    required DateTime startDate,
    required DateTime endDate,
    required bool allPromo,
    int limit = 10,
    int offset = 0,
  }) async {
    final response = await http.get(
      Uri.parse("$baseUrl/promotions").replace(queryParameters: {
        'startDateTime': startDate.toUtc().toIso8601String(),
        'endDateTime': endDate.toUtc().toIso8601String(),
        'allPromo': allPromo.toString(),
        'limit': limit.toString(),
        'offset': offset.toString(),
      }),
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
    );

    if (response.statusCode != 200) {
      throw Exception("Failed to fetch promotions");
    }

    final data = jsonDecode(response.body);
    return (data['data']['promotions'] as List)
        .map((e) => Promotion.fromJson(e))
        .toList();
  }

  @override
  Future<PromotionDetails> fetchPromotionDetails({
    required String token,
    required List<int> promotionIds,
  }) async {
    final response = await http.get(
      Uri.parse("$baseUrl/promotions/details").replace(queryParameters: {
        'promotionIDs': promotionIds.map((e) => e.toString()).toList(),
      }),
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
    );

    if (response.statusCode != 200) {
      throw Exception("Failed to fetch promotion details");
    }

    final data = jsonDecode(response.body);
    return PromotionDetails.fromJson(data['data']['promotions'][0]);
  }

  Future<List<PromotionNomenclature>> fetchPromotionNomenclatures({
    required String token,
    required int promotionId,
    required bool inAction,
    int limit = 10,
    int offset = 0,
  }) async {
    final response = await http.get(
      Uri.parse("$baseUrl/promotions/nomenclatures").replace(queryParameters: {
        'promotionID': promotionId.toString(),
        'inAction': inAction.toString(),
        'limit': limit.toString(),
        'offset': offset.toString(),
      }),
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
    );

    if (response.statusCode != 200) {
      throw Exception("Failed to fetch promotion nomenclatures");
    }

    final data = jsonDecode(response.body);
    return (data['data']['nomenclatures'] as List)
        .map((e) => PromotionNomenclature.fromJson(e))
        .toList();
  }
}

================
File: api/stocks.dart
================
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/entities/stock.dart';
import 'package:retrofit/retrofit.dart';
import 'package:dio/dio.dart';

part 'stocks.g.dart';

// TODO Add token
@RestApi(baseUrl: ApiSettings.baseUrl)
abstract class StocksApiClient {
  factory StocksApiClient(Dio dio, {String baseUrl}) = _StocksApiClient;

  @GET("/stocks")
  Future<StocksResponse> getStocks({
    @Query("product_id") int? productId,
    @Query("warehouse_id") int? warehouseId,
    @Query("start_date") required String startDate,
    @Query("end_date") required String endDate,
    @Query("page") int? page,
    @Query("page_size") int? pageSize,
  });
}

class StocksResponse {
  final List<Stock> stocks;

  StocksResponse({
    required this.stocks,
  });

  factory StocksResponse.fromJson(Map<String, dynamic> json) {
    if (json['stocks'] == null || json['stocks'] is! List) {
      throw FormatException(
          'Expected a list for "stocks" but got: ${json['stocks']}');
    }

    return StocksResponse(
      stocks: (json['stocks'] as List<dynamic>)
          .map((item) => Stock.fromJson(item as Map<String, dynamic>))
          .toList(),
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'stocks': stocks.map((stock) => stock.toJson()).toList(),
    };
  }
}

================
File: api/stocks.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'stocks.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _StocksApiClient implements StocksApiClient {
  _StocksApiClient(
    this._dio, {
    this.baseUrl,
    this.errorLogger,
  }) {
    baseUrl ??= 'https://marketconnect.website/api';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<StocksResponse> getStocks({
    int? productId,
    int? warehouseId,
    required String startDate,
    required String endDate,
    int? page,
    int? pageSize,
  }) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'product_id': productId,
      r'warehouse_id': warehouseId,
      r'start_date': startDate,
      r'end_date': endDate,
      r'page': page,
      r'page_size': pageSize,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<StocksResponse>(Options(
      method: 'GET',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/stocks',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late StocksResponse _value;
    try {
      _value = StocksResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(
    String dioBaseUrl,
    String? baseUrl,
  ) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

================
File: api/subjects_summary.dart
================
import 'package:mc_dashboard/.env.dart';

import 'package:retrofit/retrofit.dart';
import 'package:dio/dio.dart';

part 'subjects_summary.g.dart';

// TODO Add token
@RestApi(baseUrl: ApiSettings.baseUrl)
abstract class SubjectsSummaryApiClient {
  factory SubjectsSummaryApiClient(Dio dio, {String baseUrl}) =
      _SubjectsSummaryApiClient;

  @GET("/subjects-summary")
  Future<List<RawJsonMap>> getSubjectsSummaryAsDynamic({
    @Query("subject_id") int? subjectId,
    @Query("subject_name") String? subjectName,
    @Query("subject_parent_name") String? subjectParentName,
  });
}

/// Обёртка над Map<String, dynamic>
class RawJsonMap {
  final Map<String, dynamic> data;

  RawJsonMap(this.data);

  factory RawJsonMap.fromJson(Map<String, dynamic> json) {
    return RawJsonMap(Map<String, dynamic>.from(json));
  }
}

================
File: api/subjects_summary.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'subjects_summary.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _SubjectsSummaryApiClient implements SubjectsSummaryApiClient {
  _SubjectsSummaryApiClient(
    this._dio, {
    this.baseUrl,
    this.errorLogger,
  }) {
    baseUrl ??= 'https://marketconnect.website/api';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<List<RawJsonMap>> getSubjectsSummaryAsDynamic({
    int? subjectId,
    String? subjectName,
    String? subjectParentName,
  }) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{
      r'subject_id': subjectId,
      r'subject_name': subjectName,
      r'subject_parent_name': subjectParentName,
    };
    queryParameters.removeWhere((k, v) => v == null);
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<List<RawJsonMap>>(Options(
      method: 'GET',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/subjects-summary',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<List<dynamic>>(_options);
    late List<RawJsonMap> _value;
    try {
      _value = _result.data!
          .map((dynamic i) => RawJsonMap.fromJson(i as Map<String, dynamic>))
          .toList();
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(
    String dioBaseUrl,
    String? baseUrl,
  ) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

================
File: api/suppliers_api_client.dart
================
// import 'package:mc_dashboard/.env.dart';
// import 'package:mc_dashboard/domain/entities/supplier_item.dart';

// import 'package:retrofit/retrofit.dart';
// import 'package:dio/dio.dart';

// part 'suppliers_api_client.g.dart';

// @RestApi(baseUrl: ApiSettings.baseUrl)
// abstract class SuppliersApiClient {
//   factory SuppliersApiClient(Dio dio, {String baseUrl}) = _SuppliersApiClient;

//   @GET("/suppliers/{ids}")
//   Future<List<SupplierItem>> getSuppliers({
//     @Path("ids") required String supplierIds,
//   });
// }

================
File: api/user_emails_api.dart
================
import 'dart:convert';
// ignore: depend_on_referenced_packages
import 'package:http/http.dart' as http;
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/services/user_emails_service.dart';

class UserEmailsApiClient implements UserEmailsServiceApiClient {
  final String baseUrl = ApiSettings.subsUrl;

  const UserEmailsApiClient();

  @override
  Future<UserEmailsResponse> findUserEmails({required String token}) async {
    final url = Uri.parse('$baseUrl/user_emails');
    final response = await http.get(
      url,
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
    );
    if (response.statusCode == 200) {
      if (response.body.isEmpty) {
        return UserEmailsResponse(emails: []);
      }
      return UserEmailsResponse.fromJson(jsonDecode(response.body));
    } else {
      throw Exception('Failed to fetch emails: ${response.body}');
    }
  }

  @override
  Future<void> saveUserEmails(
      {required String token, required SaveEmailsRequest request}) async {
    final response = await http.post(
      Uri.parse('$baseUrl/user_emails'),
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
      body: jsonEncode(request.toJson()),
    );
    if (response.statusCode == 200) {
      return;
    } else {
      throw Exception('Failed to save emails: ${response.body}');
    }
  }

  @override
  Future<void> deleteUserEmails(
      {required String token, required DeleteEmailsRequest request}) async {
    final response = await http.delete(
      Uri.parse('$baseUrl/user_emails'),
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
      body: jsonEncode(request.toJson()),
    );

    if (response.statusCode == 200) {
      return;
    } else {
      throw Exception('Failed to delete emails: ${response.body}');
    }
  }
}

// Request class for saving user emails
class SaveEmailsRequest {
  final List<String> emails;

  SaveEmailsRequest({
    required this.emails,
  });

  factory SaveEmailsRequest.fromJson(Map<String, dynamic> json) =>
      SaveEmailsRequest(
        emails: (json['emails'] as List<dynamic>).cast<String>(),
      );

  Map<String, dynamic> toJson() => {
        'emails': emails,
      };
}

// Request class for deleting user emails
class DeleteEmailsRequest {
  final List<String> emails;

  DeleteEmailsRequest({
    required this.emails,
  });

  factory DeleteEmailsRequest.fromJson(Map<String, dynamic> json) =>
      DeleteEmailsRequest(
        emails: (json['emails'] as List<dynamic>).cast<String>(),
      );

  Map<String, dynamic> toJson() => {
        'emails': emails,
      };
}

// Response class for fetching user emails
class UserEmailsResponse {
  final List<String> emails;

  UserEmailsResponse({
    required this.emails,
  });

  factory UserEmailsResponse.fromJson(Map<String, dynamic> json) {
    if (json['emails'] == null || json['emails'] == '') {
      return UserEmailsResponse(emails: []);
    }
    return UserEmailsResponse(
      emails: (json['emails'] as List<dynamic>)
          .map((item) => item as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() => {
        'emails': emails,
      };
}

================
File: api/user_search_queries_api.dart
================
import 'dart:convert';
// ignore: depend_on_referenced_packages
import 'package:http/http.dart' as http;
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/entities/key_phrase.dart';
import 'package:mc_dashboard/domain/services/saved_key_phrases_service.dart';

class UserSearchQueriesApiClient implements SavedKeyPhrasesApiClient {
  final String baseUrl = ApiSettings.subsUrl;

  UserSearchQueriesApiClient();

  @override
  Future<List<KeyPhrase>> findUserSearchQueries({
    required String token,
  }) async {
    final url = Uri.parse('$baseUrl/user_search_queries');

    final response = await http.get(
      url,
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json',
      },
    );

    if (response.statusCode == 200) {
      final data = UserSearchQueriesResponse.fromJson(
          json.decode(response.body) as Map<String, dynamic>);
      List<KeyPhrase> keyPhrases = [];

      for (var query in data.searchQueries) {
        keyPhrases.add(KeyPhrase(
          phraseText: query.query,
          marketPlace: query.marketplaceType,
        ));
      }

      return keyPhrases;
    } else {
      throw Exception('Failed to fetch search queries: ${response.body}');
    }
  }

  @override
  Future<void> saveUserSearchQueries({
    required String token,
    required List<KeyPhrase> phrases,
  }) async {
    final url = Uri.parse('$baseUrl/user_search_queries');

    final request = SaveQueriesRequest(
      searchQueries: phrases
          .map((phrase) => SearchQuery(
                query: phrase.phraseText,
                marketplaceType: phrase.marketPlace,
              ))
          .toList(),
    );

    final response = await http.post(
      url,
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json',
      },
      body: json.encode(request.toJson()),
    );

    if (response.statusCode == 200) {
      return;
    } else {
      throw Exception('Failed to save search queries: ${response.body}');
    }
  }

  @override
  Future<void> deleteUserSearchQueries({
    required String token,
    required List<KeyPhrase> phrases,
  }) async {
    final url = Uri.parse('$baseUrl/user_search_queries');

    final request = DeleteQueriesRequest(
      searchQueries: phrases
          .map((phrase) => SearchQuery(
                query: phrase.phraseText,
                marketplaceType: phrase.marketPlace,
              ))
          .toList(),
    );

    final response = await http.delete(
      url,
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json',
      },
      body: json.encode(request.toJson()),
    );

    if (response.statusCode == 200) {
      return;
    } else {
      throw Exception('Failed to delete search queries: ${response.body}');
    }
  }
}

// Request class for saving user search queries
class SaveQueriesRequest {
  final List<SearchQuery> searchQueries;

  SaveQueriesRequest({
    required this.searchQueries,
  });

  Map<String, dynamic> toJson() => {
        'search_queries': searchQueries.map((query) => query.toJson()).toList(),
      };
}

// Request class for deleting user search queries
class DeleteQueriesRequest {
  final List<SearchQuery> searchQueries;

  DeleteQueriesRequest({
    required this.searchQueries,
  });

  Map<String, dynamic> toJson() => {
        'search_queries': searchQueries.map((query) => query.toJson()).toList(),
      };
}

// Response class for fetching user search queries
class UserSearchQueriesResponse {
  final List<SearchQuery> searchQueries;

  UserSearchQueriesResponse({required this.searchQueries});

  factory UserSearchQueriesResponse.fromJson(Map<String, dynamic> json) {
    if (json['search_queries'] == null || json['search_queries'] == '') {
      return UserSearchQueriesResponse(searchQueries: []);
    }
    return UserSearchQueriesResponse(
      searchQueries: (json['search_queries'] as List<dynamic>)
          .map((e) => SearchQuery.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }
}

// Entity representing a search query
class SearchQuery {
  final String query;
  final String marketplaceType;

  SearchQuery({
    required this.query,
    required this.marketplaceType,
  });

  factory SearchQuery.fromJson(Map<String, dynamic> json) {
    return SearchQuery(
      query: json['query'] as String,
      marketplaceType: json['marketplace_type'] as String,
    );
  }

  Map<String, dynamic> toJson() => {
        'query': query,
        'marketplace_type': marketplaceType,
      };
}

================
File: api/user_settings_api.dart
================
import 'dart:convert';
// ignore: depend_on_referenced_packages
import 'package:http/http.dart' as http;
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/entities/mailing_settings.dart';
import 'package:mc_dashboard/domain/services/user_sub_settings_service.dart';

class UserSettingsApiClient implements UserSubSettingsApiClient {
  final String baseUrl = ApiSettings.subsUrl;

  UserSettingsApiClient();

  @override
  Future<List<Setting>> findUserSettings({
    required String token,
  }) async {
    final response = await http.get(
      Uri.parse('$baseUrl/user_settings'),
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
    );

    if (response.statusCode == 200) {
      final resp = UserSettingsResponse.fromJson(json.decode(response.body));

      return resp.settings;
    } else {
      throw Exception('Failed to fetch user settings: ${response.body}');
    }
  }

  @override
  Future<void> saveUserSettings({
    required String token,
    required List<Setting> settings,
  }) async {
    final request = SaveSettingsRequest(settings: settings);
    final response = await http.post(
      Uri.parse('$baseUrl/user_settings'),
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
      body: json.encode(request.toJson()),
    );

    if (response.statusCode == 200) {
      return;
    } else {
      throw Exception('Failed to save user settings: ${response.body}');
    }
  }

  @override
  Future<void> deleteUserSettings({
    required String token,
    required List<Setting> settings,
  }) async {
    final request = DeleteSettingsRequest(settings: settings);
    final response = await http.delete(
      Uri.parse('$baseUrl/user_settings'),
      headers: {
        'Authorization': 'Bearer $token',
        'Content-Type': 'application/json',
      },
      body: json.encode(request.toJson()),
    );

    if (response.statusCode == 200) {
      return;
    } else {
      throw Exception('Failed to delete user settings: ${response.body}');
    }
  }
}

class SaveSettingsRequest {
  final List<Setting> settings;

  SaveSettingsRequest({
    required this.settings,
  });

  Map<String, dynamic> toJson() => {
        'settings': settings.map((setting) => setting.toJson()).toList(),
      };
}

class DeleteSettingsRequest {
  final List<Setting> settings;

  DeleteSettingsRequest({
    required this.settings,
  });

  Map<String, dynamic> toJson() => {
        'settings': settings.map((setting) => setting.toJson()).toList(),
      };
}

class UserSettingsResponse {
  final List<Setting> settings;

  UserSettingsResponse({
    required this.settings,
  });

  factory UserSettingsResponse.fromJson(Map<String, dynamic> json) {
    if (json['settings'] == null || json['settings'] == '') {
      return UserSettingsResponse(settings: []);
    }
    return UserSettingsResponse(
      settings: (json['settings'] as List<dynamic>)
          .map((item) => Setting.fromJson(item as Map<String, dynamic>))
          .toList(),
    );
  }
}

================
File: api/user_skus_api.dart
================
import 'dart:convert';
// ignore: depend_on_referenced_packages
import 'package:http/http.dart' as http;
import 'package:mc_dashboard/.env.dart';

import 'package:mc_dashboard/domain/entities/sku.dart';
import 'package:mc_dashboard/domain/services/saved_products_service.dart';

class UserSkusApiClient implements SavedProductsApiClient {
  final String baseUrl = ApiSettings.subsUrl;

  UserSkusApiClient();

  @override
  Future<List<Sku>> findUserSkus({
    required String token,
  }) async {
    final url = Uri.parse('$baseUrl/user_skus');

    final response = await http.get(
      url,
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json',
      },
    );
    print("GET SKUS resp body: ${response.body}");

    if (response.statusCode == 200) {
      final resp = UserSkusResponse.fromJson(jsonDecode(response.body));
      List<Sku> productSkus = [];

      for (var product in resp.skus) {
        productSkus.add(Sku(
          id: product.id,
          marketplaceType: product.marketplaceType,
          sellerId: product.sellerId,
          sellerName: product.sellerName,
          brandId: product.brandId,
          brandName: product.brandName,
        ));
      }

      return productSkus;
    } else {
      throw Exception('Failed to fetch user SKUs: ${response.body}');
    }
  }

  @override
  Future<void> saveUserSkus({
    required String token,
    required List<Sku> skus,
  }) async {
    final request = SaveSkusRequest(skus: skus);
    final url = Uri.parse('$baseUrl/user_skus');

    final response = await http.post(
      url,
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json',
      },
      body: jsonEncode(request.toJson()),
    );

    if (response.statusCode == 200) {
      return;
    } else {
      throw Exception('Failed to save user SKUs: ${response.body}');
    }
  }

  @override
  Future<void> deleteUserSkus({
    required String token,
    required List<Sku> skus,
  }) async {
    final request = DeleteSkusRequest(skus: skus);
    final url = Uri.parse('$baseUrl/user_skus');

    final response = await http.delete(
      url,
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json',
      },
      body: jsonEncode(request.toJson()),
    );

    if (response.statusCode == 200) {
      return;
    } else {
      throw Exception('Failed to delete user SKUs: ${response.body}');
    }
  }
}

// Request class for saving SKUs
class SaveSkusRequest {
  final List<Sku> skus;

  SaveSkusRequest({
    required this.skus,
  });

  Map<String, dynamic> toJson() => {
        'skus': skus.map((sku) => sku.toJson()).toList(),
      };
}

// Request class for deleting SKUs
class DeleteSkusRequest {
  final List<Sku> skus;

  DeleteSkusRequest({
    required this.skus,
  });

  Map<String, dynamic> toJson() => {
        'skus': skus.map((sku) => sku.toJson()).toList(),
      };
}

// Response class for fetching SKUs
class UserSkusResponse {
  final List<Sku> skus;

  UserSkusResponse({
    required this.skus,
  });

  factory UserSkusResponse.fromJson(Map<String, dynamic> json) {
    if (json['skus'] == null || json['skus'] == '') {
      return UserSkusResponse(skus: []);
    }
    return UserSkusResponse(
      skus: (json['skus'] as List<dynamic>)
          .map((item) => Sku.fromJson(item as Map<String, dynamic>))
          .toList(),
    );
  }
}

// Entity representing a SKU

================
File: api/warehouses.dart
================
import 'package:mc_dashboard/.env.dart';
import 'package:mc_dashboard/domain/entities/warehouse.dart';
import 'package:dio/dio.dart';
import 'package:retrofit/retrofit.dart';

part 'warehouses.g.dart';

// TODO Add token
@RestApi(baseUrl: ApiSettings.baseUrl)
abstract class WarehousesApiClient {
  factory WarehousesApiClient(Dio dio, {String baseUrl}) = _WarehousesApiClient;

  @GET("/warehouses")
  Future<WarehousesResponse> getWarehouses({
    @Query("ids") required List<int> ids,
  });
}

class WarehousesResponse {
  final List<Warehouse> warehouses;

  WarehousesResponse({required this.warehouses});

  factory WarehousesResponse.fromJson(Map<String, dynamic> json) {
    return WarehousesResponse(
      warehouses: (json['warehouses'] as List<dynamic>)
          .map((e) => Warehouse.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() => {
        'warehouses': warehouses.map((w) => w.toJson()).toList(),
      };
}

================
File: api/warehouses.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'warehouses.dart';

// **************************************************************************
// RetrofitGenerator
// **************************************************************************

// ignore_for_file: unnecessary_brace_in_string_interps,no_leading_underscores_for_local_identifiers,unused_element,unnecessary_string_interpolations

class _WarehousesApiClient implements WarehousesApiClient {
  _WarehousesApiClient(
    this._dio, {
    this.baseUrl,
    this.errorLogger,
  }) {
    baseUrl ??= 'https://marketconnect.website/api';
  }

  final Dio _dio;

  String? baseUrl;

  final ParseErrorLogger? errorLogger;

  @override
  Future<WarehousesResponse> getWarehouses({required List<int> ids}) async {
    final _extra = <String, dynamic>{};
    final queryParameters = <String, dynamic>{r'ids': ids};
    final _headers = <String, dynamic>{};
    const Map<String, dynamic>? _data = null;
    final _options = _setStreamType<WarehousesResponse>(Options(
      method: 'GET',
      headers: _headers,
      extra: _extra,
    )
        .compose(
          _dio.options,
          '/warehouses',
          queryParameters: queryParameters,
          data: _data,
        )
        .copyWith(
            baseUrl: _combineBaseUrls(
          _dio.options.baseUrl,
          baseUrl,
        )));
    final _result = await _dio.fetch<Map<String, dynamic>>(_options);
    late WarehousesResponse _value;
    try {
      _value = WarehousesResponse.fromJson(_result.data!);
    } on Object catch (e, s) {
      errorLogger?.logError(e, s, _options);
      rethrow;
    }
    return _value;
  }

  RequestOptions _setStreamType<T>(RequestOptions requestOptions) {
    if (T != dynamic &&
        !(requestOptions.responseType == ResponseType.bytes ||
            requestOptions.responseType == ResponseType.stream)) {
      if (T == String) {
        requestOptions.responseType = ResponseType.plain;
      } else {
        requestOptions.responseType = ResponseType.json;
      }
    }
    return requestOptions;
  }

  String _combineBaseUrls(
    String dioBaseUrl,
    String? baseUrl,
  ) {
    if (baseUrl == null || baseUrl.trim().isEmpty) {
      return dioBaseUrl;
    }

    final url = Uri.parse(baseUrl);

    if (url.isAbsolute) {
      return url.toString();
    }

    return Uri.parse(dioBaseUrl).resolveUri(url).toString();
  }
}

================
File: repositories/api_key_storage.dart
================
import 'package:idb_shim/idb_browser.dart';
import 'package:mc_dashboard/domain/services/api_key_service.dart';

class ApiKeyRepo implements ApiKeyServiceStorage {
  final String dbName = 'MyDB';
  final int dbVersion = 1;
  final String storeName = 'tokens';

  Future<Database> _openDatabase() async {
    return await idbFactoryBrowser.open(dbName, version: dbVersion,
        onUpgradeNeeded: (event) {
      var db = event.database;
      if (!db.objectStoreNames.contains(storeName)) {
        db.createObjectStore(storeName);
      }
    });
  }

  @override
  Future<void> saveApiToken(String keyName, String token) async {
    var db = await _openDatabase();
    var txn = db.transaction(storeName, 'readwrite');
    var store = txn.objectStore(storeName);
    await store.put(token, keyName);
    await txn.completed;
  }

  @override
  Future<String?> getApiToken(String keyName) async {
    var db = await _openDatabase();
    var txn = db.transaction(storeName, 'readonly');
    var store = txn.objectStore(storeName);
    return await store.getObject(keyName) as String?;
  }

  @override
  Future<void> deleteApiToken(String keyName) async {
    print('Удаление ключа: $keyName');
    var db = await _openDatabase();
    var txn = db.transaction(storeName, 'readwrite');
    var store = txn.objectStore(storeName);
    await store.delete(keyName);
    await txn.completed;
    print('Удалено: $keyName');
  }
}

================
File: repositories/cookies.dart
================
// import 'dart:html' as html;

// import 'package:fpdart/fpdart.dart';
// import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
// import 'package:mc_dashboard/domain/services/auth_service.dart';

// class CookiesRepo implements AuthServiceStorage {
//   const CookiesRepo();
//   @override
//   Either<AppErrorBase, void> saveToken(String token) {
//     try {
//       final cookie = 'access_token=$token; path=/; max-age=2592000'; // 30 дней
//       html.document.cookie = cookie;
//       return right(null);
//     } catch (e) {
//       return left(AppErrorBase('Catched err: $e',
//           name: 'saveTokenToCookies', sendTo: true, source: 'CookiesRepo'));
//     }
//   }

//   /// Получение токена из cookies
//   @override
//   Either<AppErrorBase, String?> getToken() {
//     try {
//       final cookies = html.document.cookie?.split('; ') ?? [];
//       for (final cookie in cookies) {
//         if (cookie.startsWith('access_token=')) {
//           return right(cookie.substring('access_token='.length));
//         }
//       }
//       return right(null);
//     } catch (e) {
//       return left(AppErrorBase('Catched err: $e',
//           name: 'getTokenFromCookies', sendTo: true, source: 'CookiesRepo'));
//     }
//   }

//   static String? getTokenFromCookiesStatic() {
//     try {
//       final cookies = html.document.cookie?.split('; ') ?? [];
//       for (final cookie in cookies) {
//         if (cookie.startsWith('access_token=')) {
//           return cookie.substring('access_token='.length);
//         }
//       }
//       return null;
//     } catch (e) {
//       return null;
//     }
//   }

//   /// Очистка токена из cookies
//   @override
//   Either<AppErrorBase, void> clearToken() {
//     try {
//       html.document.cookie = 'access_token=; path=/; max-age=0';
//       return right(null);
//     } catch (e) {
//       return left(AppErrorBase('Catched err: $e',
//           name: 'getTokenFromCookies', sendTo: true, source: 'CookiesRepo'));
//     }
//   }
// }

================
File: repositories/local_storage.dart
================
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/services/auth_service.dart';
import 'package:web/web.dart' as web;

class LocalStorageRepo implements AuthServiceStorage {
  const LocalStorageRepo();

  @override
  Either<AppErrorBase, void> saveToken(String token) {
    try {
      web.window.localStorage.setItem('access_token', token);
      return right(null);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'saveTokenToLocalStorage',
        sendTo: true,
        source: 'LocalStorageRepo',
      ));
    }
  }

  @override
  Either<AppErrorBase, String?> getToken() {
    try {
      final token = web.window.localStorage.getItem('access_token');
      return right(token);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'getTokenFromLocalStorage',
        sendTo: true,
        source: 'LocalStorageRepo',
      ));
    }
  }

  @override
  Either<AppErrorBase, void> clearToken() {
    try {
      web.window.localStorage.removeItem('access_token');
      return right(null);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'clearTokenFromLocalStorage',
        sendTo: true,
        source: 'LocalStorageRepo',
      ));
    }
  }

  static Either<AppErrorBase, void> clearTokenStatic() {
    try {
      web.window.localStorage.removeItem('access_token');
      return right(null);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'clearTokenFromLocalStorage',
        sendTo: true,
        source: 'LocalStorageRepo',
      ));
    }
  }

  static String? getTokenStatic() {
    try {
      final token = web.window.localStorage.getItem('access_token');
      return token;
    } catch (e) {
      return null;
    }
  }
}

================
File: repositories/mailing_settings_repo.dart
================
import 'package:hive/hive.dart';
import 'package:mc_dashboard/domain/entities/mailing_settings.dart';
import 'package:mc_dashboard/domain/services/user_sub_settings_service.dart';

class MailingSettingsRepo implements UserSubSettingsRepoRepository {
  @override
  Future<void> saveSettings(Map<String, dynamic> newSettings) async {
    final box = await Hive.openBox<DynamicMailingSettings>('mailingSettings');
    final existingSettings = box.get('userSettings')?.settings ?? {};
    final updatedSettings = {...existingSettings, ...newSettings};
    await box.put(
        'userSettings', DynamicMailingSettings(settings: updatedSettings));
  }

  @override
  Future<Map<String, dynamic>> getSettings() async {
    final box = await Hive.openBox<DynamicMailingSettings>('mailingSettings');
    return box.get('userSettings')?.settings ?? {};
  }

  @override
  Future<void> deleteSetting(String key) async {
    final box = await Hive.openBox<DynamicMailingSettings>('mailingSettings');
    final currentSettings = box.get('userSettings');

    if (currentSettings != null && currentSettings.settings.containsKey(key)) {
      final updatedSettings = {...currentSettings.settings};
      updatedSettings.remove(key);

      await box.put(
          'userSettings', DynamicMailingSettings(settings: updatedSettings));
    }
  }
}

================
File: repositories/saved_key_phrases_repo.dart
================
import 'package:hive/hive.dart';
import 'package:mc_dashboard/domain/entities/key_phrase.dart';
import 'package:mc_dashboard/domain/services/saved_key_phrases_service.dart';

class SavedKeyPhrasesRepo implements SavedKeyPhrasesRepository {
  @override
  Future<void> saveKeyPhrase(KeyPhrase keyPhrase) async {
    final box = await Hive.openBox<KeyPhrase>('keyPhrases');

    if (!box.containsKey(keyPhrase.phraseText)) {
      await box.put(keyPhrase.phraseText, keyPhrase);
    }
  }

  @override
  Future<void> deleteKeyPhrase(String phraseText) async {
    final box = await Hive.openBox<KeyPhrase>('keyPhrases');

    if (box.containsKey(phraseText)) {
      await box.delete(phraseText);
    }
  }

  @override
  Future<List<KeyPhrase>> getAllKeyPhrases() async {
    final box = await Hive.openBox<KeyPhrase>('keyPhrases');
    return box.values.toList();
  }
}

================
File: repositories/saved_products_repo.dart
================
import 'package:hive/hive.dart';
import 'package:mc_dashboard/domain/entities/saved_product.dart';
import 'package:mc_dashboard/domain/services/saved_products_service.dart';

class SavedProductsRepo implements SavedProductsRepository {
  @override
  Future<void> saveProduct(SavedProduct product) async {
    final box = await Hive.openBox<SavedProduct>('savedProducts');
    await box.put(product.productId, product);
  }

  @override
  Future<List<SavedProduct>> loadProducts() async {
    final box = await Hive.openBox<SavedProduct>('savedProducts');
    return box.values.toList();
  }

  @override
  Future<void> deleteProduct(String productId) async {
    final box = await Hive.openBox<SavedProduct>('savedProducts');

    if (box.containsKey(productId)) {
      await box.delete(productId);
    }
  }
}

================
File: repositories/user_email_repo.dart
================
import 'package:hive/hive.dart';
import 'package:mc_dashboard/domain/entities/user_email.dart';
import 'package:mc_dashboard/domain/services/user_emails_service.dart';

class UserEmailsRepo implements UserEmailsRepoRepository {
  @override
  Future<void> saveUserEmail(UserEmail userEmail) async {
    final box = await Hive.openBox<UserEmail>('userEmails');

    if (!box.values.any((email) => email.email == userEmail.email)) {
      await box.add(userEmail); // Добавляем email, если его еще нет
    }
  }

  @override
  Future<void> deleteUserEmail(String email) async {
    final box = await Hive.openBox<UserEmail>('userEmails');

    final emailKey = box.keys.firstWhere(
      (key) => box.get(key)!.email == email,
      orElse: () => null,
    );

    if (emailKey != null) {
      await box.delete(emailKey);
    }
  }

  @override
  Future<List<UserEmail>> getAllUserEmails() async {
    final box = await Hive.openBox<UserEmail>('userEmails');
    return box.values.toList();
  }
}



================================================================
End of Codebase
================================================================
