This file is a merged representation of the entire codebase, combined into a single document.
Generated by Repomix on: 2025-02-10T16:49:15.889Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
entities/
  card_info.dart
  detailed_order_item.dart
  feedback_info.dart
  key_phrase.dart
  key_phrase.g.dart
  kw_lemmas.dart
  lemmatize.dart
  mailing_settings.dart
  mailing_settings.g.dart
  normquery_product.dart
  normquery.dart
  order.dart
  product_item.dart
  promotions.dart
  saved_product.dart
  saved_product.g.dart
  sku.dart
  stock.dart
  subject_summary_item.dart
  supplier_item.dart
  token_info.dart
  user_email.dart
  user_email.g.dart
  warehouse.dart
services/
  api_key_service.dart
  auth_service.dart
  detailed_orders_service.dart
  kw_lemmas_service.dart
  lemmatize_service.dart
  normqueries_service.dart
  orders_service.dart
  products_service.dart
  promotion_service.dart
  saved_key_phrases_service.dart
  saved_products_service.dart
  stocks_service.dart
  subjects_summary_service.dart
  suppliers_service.dart
  tinkoff_payment_service.dart
  user_emails_service.dart
  user_sub_settings_service.dart
  warehouses_service.dart

================================================================
Files
================================================================

================
File: entities/card_info.dart
================
class CardInfo {
  final String imtName;
  final int imtId;
  final int supplierId;
  final int photoCount;
  final int subjId;
  final String subjName;

  final String brand;
  final String description;
  final String characteristicValues;
  final String characteristicFull;

  CardInfo({
    required this.imtName,
    required this.imtId,
    required this.supplierId,
    required this.photoCount,
    required this.subjId,
    required this.subjName,
    required this.brand,
    required this.description,
    required this.characteristicValues,
    required this.characteristicFull,
  });

  factory CardInfo.fromJson(Map<String, dynamic> json) {
    final media = json['media'];

    final optionsText = (json['options'] as List<dynamic>?)
            ?.map((option) => option['value'] as String)
            .join('; ') ??
        '';

    final compositionsText = (json['compositions'] as List<dynamic>?)
            ?.map((composition) => composition['name'] as String)
            .join('; ') ??
        '';

    final groupedOptionsText = (json['grouped_options'] as List<dynamic>?)
            ?.expand((group) =>
                (group['options'] as List<dynamic>?)
                    ?.map((option) => option['value'] as String) ??
                [])
            .join('; ') ??
        '';

    final characteristics = [optionsText, compositionsText, groupedOptionsText]
        .where((text) => text.isNotEmpty)
        .join('; ');

    final Map<String, String> uniqueCharacteristics = {};

    (json['options'] as List<dynamic>?)?.forEach((option) {
      final name = option['name'] as String? ?? '';
      final value = option['value'] as String? ?? '';
      if (name.isNotEmpty && value.isNotEmpty) {
        uniqueCharacteristics[name] = value;
      }
    });

    (json['grouped_options'] as List<dynamic>?)?.forEach((group) {
      (group['options'] as List<dynamic>?)?.forEach((option) {
        final name = option['name'] as String? ?? '';
        final value = option['value'] as String? ?? '';
        if (name.isNotEmpty && value.isNotEmpty) {
          uniqueCharacteristics[name] = value;
        }
      });
    });

    final characteristicFull = uniqueCharacteristics.entries
        .map((entry) => '${entry.key}: ${entry.value}')
        .join('; ');

    String brand = "";
    if (json['selling'] != null) {
      brand = json['selling']['brand_name'];
    }

    return CardInfo(
      imtName: json['imt_name'],
      imtId: json['imt_id'],
      supplierId: json['selling']['supplier_id'],
      subjName: json['subj_name'],
      subjId: json['data']['subject_id'],
      brand: brand,
      description: json['description'],
      photoCount: media['photo_count'],
      characteristicValues: characteristics,
      characteristicFull: characteristicFull,
    );
  }
}

================
File: entities/detailed_order_item.dart
================
class DetailedOrderItem {
  final int productId;
  final int subjectId;
  final int price;
  final int orders;
  final int isFbs;

  final int brandId;
  final String brand;
  final int supplierId;
  final String supplier;

  DetailedOrderItem({
    required this.productId,
    required this.subjectId,
    required this.price,
    required this.orders,
    required this.isFbs,
    required this.brandId,
    required this.brand,
    required this.supplierId,
    required this.supplier,
  });

  factory DetailedOrderItem.fromJson(Map<String, dynamic> json) {
    return DetailedOrderItem(
      productId: json['product_id'] as int,
      subjectId: json['subject_id'] as int,
      price: json['price'] as int,
      orders: json['orders'] as int,
      isFbs: json['is_fbs'] as int,
      brandId: json['brand_id'] as int,
      brand: json['brand'] as String,
      supplierId: json['supplier_id'] as int,
      supplier: json['supplier'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'product_id': productId,
      'subject_id': subjectId,
      'price': price,
      'orders': orders,
      'is_fbs': isFbs,
      'brand_id': brandId,
      'brand': brand,
      'supplier_id': supplierId,
      'supplier': supplier,
    };
  }

  DetailedOrderItem copyWith({
    int? productId,
    int? subjectId,
    int? price,
    int? orders,
    int? isFbs,
    int? brandId,
    String? brand,
    int? supplierId,
    String? supplier,
  }) {
    return DetailedOrderItem(
      productId: productId ?? this.productId,
      subjectId: subjectId ?? this.subjectId,
      price: price ?? this.price,
      orders: orders ?? this.orders,
      isFbs: isFbs ?? this.isFbs,
      brandId: brandId ?? this.brandId,
      brand: brand ?? this.brand,
      supplierId: supplierId ?? this.supplierId,
      supplier: supplier ?? this.supplier,
    );
  }
}

class DetailedOrdersResponse {
  final List<DetailedOrderItem> detailedOrders;

  DetailedOrdersResponse({required this.detailedOrders});

  factory DetailedOrdersResponse.fromJson(Map<String, dynamic> json) {
    return DetailedOrdersResponse(
      detailedOrders: (json['detailed_orders30d'] as List)
          .map((item) => DetailedOrderItem.fromJson(item))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'detailed_orders30d':
          detailedOrders.map((item) => item.toJson()).toList(),
    };
  }
}

================
File: entities/feedback_info.dart
================
class FeedbackInfo {
  final Map<String, int> valuationDistributionPercent;
  final String valuation;
  final List<String> pros;
  final List<String> cons;

  FeedbackInfo({
    required this.valuationDistributionPercent,
    required this.valuation,
    required this.pros,
    required this.cons,
  });

  factory FeedbackInfo.fromJson(Map<String, dynamic> json) {
    final feedbacks = json['feedbacks'] as List<dynamic>? ?? [];
    final prosList = <String>[];
    final consList = <String>[];

    for (var feedback in feedbacks) {
      if (feedback['pros'] != null && feedback['pros'].isNotEmpty) {
        prosList.add(feedback['pros']);
      }
      if (feedback['cons'] != null && feedback['cons'].isNotEmpty) {
        consList.add(feedback['cons']);
      }
    }
    return FeedbackInfo(
      valuationDistributionPercent:
          Map<String, int>.from(json['valuationDistributionPercent']),
      valuation: json['valuation'],
      pros: prosList,
      cons: consList,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'valuationDistributionPercent': valuationDistributionPercent,
      'valuation': valuation,
      'pros': pros,
      'cons': cons,
    };
  }
}

================
File: entities/key_phrase.dart
================
import 'package:hive/hive.dart';

part 'key_phrase.g.dart';

@HiveType(typeId: 1)
class KeyPhrase {
  @HiveField(0)
  final String phraseText;

  @HiveField(1)
  final String marketPlace;

  KeyPhrase({
    required this.phraseText,
    required this.marketPlace,
  });
}

================
File: entities/key_phrase.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'key_phrase.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class KeyPhraseAdapter extends TypeAdapter<KeyPhrase> {
  @override
  final int typeId = 1;

  @override
  KeyPhrase read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return KeyPhrase(
      phraseText: fields[0] as String,
      marketPlace: fields[1] as String,
    );
  }

  @override
  void write(BinaryWriter writer, KeyPhrase obj) {
    writer
      ..writeByte(2)
      ..writeByte(0)
      ..write(obj.phraseText)
      ..writeByte(1)
      ..write(obj.marketPlace);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPhraseAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

================
File: entities/kw_lemmas.dart
================
class KwLemmaItem {
  final int kwId;
  final List<String> lemmas;

  KwLemmaItem({
    required this.kwId,
    required this.lemmas,
  });

  factory KwLemmaItem.fromJson(Map<String, dynamic> json) {
    return KwLemmaItem(
      kwId: json['kw_id'] as int,
      lemmas:
          (json['lemmas'] as List<dynamic>).map((e) => e as String).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'kw_id': kwId,
      'lemmas': lemmas,
    };
  }

  KwLemmaItem copyWith({
    int? kwId,
    List<String>? lemmas,
  }) {
    return KwLemmaItem(
      kwId: kwId ?? this.kwId,
      lemmas: lemmas ?? this.lemmas,
    );
  }
}

================
File: entities/lemmatize.dart
================
class LemmatizeRequest {
  final String title;
  final String characteristics;
  final String description;

  LemmatizeRequest({
    required this.title,
    required this.characteristics,
    required this.description,
  });

  factory LemmatizeRequest.fromJson(Map<String, dynamic> json) {
    return LemmatizeRequest(
      title: json['title'] as String,
      characteristics: json['characteristics'] as String,
      description: json['description'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'title': title,
      'characteristics': characteristics,
      'description': description,
    };
  }

  @override
  String toString() => toJson().toString();
}

class LemmatizeResponse {
  final String title;
  final String characteristics;
  final String description;

  LemmatizeResponse({
    required this.title,
    required this.characteristics,
    required this.description,
  });

  factory LemmatizeResponse.fromJson(Map<String, dynamic> json) {
    return LemmatizeResponse(
      title: json['title'] as String,
      characteristics: json['characteristics'] as String,
      description: json['description'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'title': title,
      'characteristics': characteristics,
      'description': description,
    };
  }
}

================
File: entities/mailing_settings.dart
================
import 'package:hive/hive.dart';

part 'mailing_settings.g.dart';

@HiveType(typeId: 3)
class DynamicMailingSettings {
  @HiveField(0)
  final Map<String, dynamic> settings;

  DynamicMailingSettings({required this.settings});

  factory DynamicMailingSettings.fromJson(Map<String, dynamic> json) {
    return DynamicMailingSettings(settings: json);
  }

  Map<String, dynamic> toJson() => settings;

  DynamicMailingSettings copyWith(Map<String, dynamic> updates) {
    return DynamicMailingSettings(settings: {...settings, ...updates});
  }
}

class Setting {
  final String key;
  final String value;

  Setting({
    required this.key,
    required this.value,
  });

  factory Setting.fromJson(Map<String, dynamic> json) => Setting(
        key: json['key'] as String,
        value: json['value'] as String,
      );

  Map<String, dynamic> toJson() => {
        'key': key,
        'value': value,
      };
}

================
File: entities/mailing_settings.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'mailing_settings.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class DynamicMailingSettingsAdapter
    extends TypeAdapter<DynamicMailingSettings> {
  @override
  final int typeId = 3;

  @override
  DynamicMailingSettings read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return DynamicMailingSettings(
      settings: (fields[0] as Map).cast<String, dynamic>(),
    );
  }

  @override
  void write(BinaryWriter writer, DynamicMailingSettings obj) {
    writer
      ..writeByte(1)
      ..writeByte(0)
      ..write(obj.settings);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DynamicMailingSettingsAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

================
File: entities/normquery_product.dart
================
class NormqueryProduct {
  final int normqueryId;
  final String normquery;
  final int total;
  final int freq;
  final int pagePos;
  final int pageNumber;
  final int productId;

  NormqueryProduct({
    required this.normqueryId,
    required this.normquery,
    required this.total,
    required this.freq,
    required this.pagePos,
    required this.pageNumber,
    required this.productId,
  });

  factory NormqueryProduct.fromJson(Map<String, dynamic> json) {
    return NormqueryProduct(
      normqueryId: json['normquery_id'] as int,
      normquery: json['normquery'] as String,
      total: json['total'] as int,
      freq: json['freq'] as int,
      pagePos: json['page_pos'] as int,
      pageNumber: json['page_number'] as int,
      productId: json['product_id'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'normquery_id': normqueryId,
      'normquery': normquery,
      'total': total,
      'freq': freq,
      'page_pos': pagePos,
      'page_number': pageNumber,
      'product_id': productId,
    };
  }
}

// List<NormqueryProduct> generateRandomNormqueryProducts(int count) {
//   final random = Random();
//   final List<NormqueryProduct> products = [];

//   for (int i = 0; i < count; i++) {
//     final normqueryId = random.nextInt(10000);
//     final productId = random.nextInt(1000);
//     final pageNumber = random.nextInt(100) + 1;
//     final pagePos = random.nextInt(10) + 1;
//     final freq = random.nextInt(1000) + 1;
//     final total = random.nextInt(10000) + 1;

//     final someRandomKeywords = [
//       "женская обувь",
//       "летние платья",
//       "мужские кроссовки",
//       "аксессуары для авто",
//       "косметика и парфюмерия",
//       "спортивный инвентарь",
//       "детские игрушки",
//     ];
//     products.add(NormqueryProduct(
//       normqueryId: normqueryId,
//       normquery:
//           '${someRandomKeywords[random.nextInt(someRandomKeywords.length)]} $normqueryId',
//       total: total,
//       freq: freq,
//       pagePos: pagePos,
//       pageNumber: pageNumber,
//       productId: productId,
//     ));
//   }

//   return products;
// }

================
File: entities/normquery.dart
================
import 'dart:math';

class Normquery {
  final int normqueryId;
  final String normquery;
  final String kw;
  final int total;
  final int freq;

  Normquery({
    required this.normqueryId,
    required this.normquery,
    required this.kw,
    required this.total,
    required this.freq,
  });

  factory Normquery.fromJson(Map<String, dynamic> json) {
    return Normquery(
      normqueryId: json['normquery_id'] as int,
      normquery: json['normquery'] as String,
      kw: json['kw'] as String,
      total: json['total'] as int,
      freq: json['freq'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'normquery_id': normqueryId,
      'normquery': normquery,
      'kw': kw,
      'total': total,
      'freq': freq,
    };
  }
}

List<Normquery> generateRandomNormqueries(int count) {
  final random = Random();
  final List<Normquery> products = [];

  for (int i = 0; i < count; i++) {
    final normqueryId = random.nextInt(10000);
    final kw = 'KW $normqueryId';
    final normquery = 'Query $normqueryId';
    final freq = random.nextInt(1000) + 1;
    final total = random.nextInt(10000) + 1;

    products.add(Normquery(
      normqueryId: normqueryId,
      normquery: normquery,
      kw: kw,
      total: total,
      freq: freq,
    ));
  }

  return products;
}

================
File: entities/order.dart
================
import 'package:mc_dashboard/domain/entities/warehouse.dart';

class OrderWb {
  final int productId;
  final int sizeOptionId;
  final int warehouseId;
  final int price;
  final int orders;
  final DateTime timestamp;

  OrderWb({
    required this.productId,
    required this.sizeOptionId,
    required this.warehouseId,
    required this.price,
    required this.orders,
    required this.timestamp,
  });

  factory OrderWb.fromJson(Map<String, dynamic> json) {
    return OrderWb(
      productId: json['product_id'] as int,
      sizeOptionId: json['size_option_id'] as int,
      warehouseId: json['warehouse_id'] as int,
      price: json['price'] as int,
      orders: json['orders'] as int,
      timestamp: DateTime.parse(json['timestamp'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'product_id': productId,
      'size_option_id': sizeOptionId,
      'warehouse_id': warehouseId,
      'price': price,
      'orders': orders,
      'timestamp': timestamp.toIso8601String(),
    };
  }
}

List<Map<String, dynamic>> aggregateOrdersByDay(List<OrderWb> orders) {
  final Map<DateTime, int> aggregatedOrders = {};

  for (var order in orders) {
    final date = DateTime(
        order.timestamp.year, order.timestamp.month, order.timestamp.day);
    aggregatedOrders[date] = (aggregatedOrders[date] ?? 0) + order.orders;
  }

  // TODO DROP ME
  List<int> values = aggregatedOrders.values.toList();
  if (values.isNotEmpty) {
    values.sort();
    final q1 = values[(values.length * 0.25).toInt()];
    final q3 = values[(values.length * 0.75).toInt()];
    final iqr = q3 - q1;
    // final lowerBound = q1 - (1.5 * iqr);
    final upperBound = q3 + (1.5 * iqr);

    aggregatedOrders
        .removeWhere((_, totalOrders) => totalOrders > (upperBound * 5));
  }
  // TODO DROP ME ABOBE

  return aggregatedOrders.entries.map((entry) {
    return {
      'date': entry.key,
      'totalOrders': entry.value,
    };
  }).toList();
}

List<Map<String, dynamic>> aggregatePricesByDay(List<OrderWb> orders) {
  final Map<DateTime, List<int>> pricesByDate = {};

  for (var order in orders) {
    final date = DateTime(
        order.timestamp.year, order.timestamp.month, order.timestamp.day);
    if (order.price > 0) {
      pricesByDate.putIfAbsent(date, () => []).add(order.price);
    }
  }

  return pricesByDate.entries.map((entry) {
    final prices = entry.value;
    final price = prices.isNotEmpty
        ? prices.reduce((value, element) =>
            prices.where((p) => p == value).length >
                    prices.where((p) => p == element).length
                ? value
                : element)
        : 0; // Если все записи для дня с ценой 0, возвращаем 0

    return {
      'date': entry.key,
      'price': price,
    };
  }).toList();
}

int getTotalOrders(List<OrderWb> orders) {
  return orders.fold(0, (total, order) => total + order.orders);
}

Map<String, double> getTotalOrdersByWarehouse(
    List<OrderWb> orders, List<Warehouse> warehouses) {
  Map<int, int> warehouseOrders = {};

  for (var order in orders) {
    if (order.orders == 0) {
      continue;
    }
    warehouseOrders.update(
      order.warehouseId,
      (currentSum) => currentSum + order.orders,
      ifAbsent: () => order.orders,
    );
  }

  return warehouseOrders.map((key, value) {
    String whName = '';
    final warehousesNames = warehouses.where((e) => e.id == key);
    if (warehousesNames.isNotEmpty) {
      whName = warehousesNames.first.name;
    }
    return MapEntry(whName, value.toDouble());
  });
}

// Map<String, double> transformMap(Map<int, int> inputMap) {
//   return inputMap.map((key, value) {
//     return MapEntry(key.toString(), value.toDouble());
//   });
// }

================
File: entities/product_item.dart
================
class ProductItem {
  final int id;
  final int brandId;
  final int subjectId;
  final int supplierId;

  ProductItem({
    required this.id,
    required this.brandId,
    required this.subjectId,
    required this.supplierId,
  });

  factory ProductItem.fromJson(Map<String, dynamic> json) {
    return ProductItem(
      id: json['id'] as int,
      brandId: json['brand_id'] as int,
      subjectId: json['subject_id'] as int,
      supplierId: json['supplier_id'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'brand_id': brandId,
      'subject_id': subjectId,
      'supplier_id': supplierId,
    };
  }
}

================
File: entities/promotions.dart
================
class Promotion {
  final int id;
  final String name;
  final DateTime startDateTime;
  final DateTime endDateTime;
  final String type;

  Promotion({
    required this.id,
    required this.name,
    required this.startDateTime,
    required this.endDateTime,
    required this.type,
  });

  factory Promotion.fromJson(Map<String, dynamic> json) {
    return Promotion(
      id: json['id'] as int,
      name: json['name'] as String,
      startDateTime: DateTime.parse(json['startDateTime']),
      endDateTime: DateTime.parse(json['endDateTime']),
      type: json['type'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'startDateTime': startDateTime.toIso8601String(),
      'endDateTime': endDateTime.toIso8601String(),
      'type': type,
    };
  }
}

class PromotionDetails {
  final int id;
  final String name;
  final String description;
  final List<String> advantages;
  final DateTime startDateTime;
  final DateTime endDateTime;
  final int inPromoActionLeftovers;
  final int inPromoActionTotal;
  final int notInPromoActionLeftovers;
  final int notInPromoActionTotal;
  final int participationPercentage;
  final String type;
  final int exceptionProductsCount;

  PromotionDetails({
    required this.id,
    required this.name,
    required this.description,
    required this.advantages,
    required this.startDateTime,
    required this.endDateTime,
    required this.inPromoActionLeftovers,
    required this.inPromoActionTotal,
    required this.notInPromoActionLeftovers,
    required this.notInPromoActionTotal,
    required this.participationPercentage,
    required this.type,
    required this.exceptionProductsCount,
  });

  factory PromotionDetails.fromJson(Map<String, dynamic> json) {
    return PromotionDetails(
      id: json['id'] as int,
      name: json['name'] as String,
      description: json['description'] as String,
      advantages: List<String>.from(json['advantages']),
      startDateTime: DateTime.parse(json['startDateTime']),
      endDateTime: DateTime.parse(json['endDateTime']),
      inPromoActionLeftovers: json['inPromoActionLeftovers'] as int,
      inPromoActionTotal: json['inPromoActionTotal'] as int,
      notInPromoActionLeftovers: json['notInPromoActionLeftovers'] as int,
      notInPromoActionTotal: json['notInPromoActionTotal'] as int,
      participationPercentage: json['participationPercentage'] as int,
      type: json['type'] as String,
      exceptionProductsCount: json['exceptionProductsCount'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'advantages': advantages,
      'startDateTime': startDateTime.toIso8601String(),
      'endDateTime': endDateTime.toIso8601String(),
      'inPromoActionLeftovers': inPromoActionLeftovers,
      'inPromoActionTotal': inPromoActionTotal,
      'notInPromoActionLeftovers': notInPromoActionLeftovers,
      'notInPromoActionTotal': notInPromoActionTotal,
      'participationPercentage': participationPercentage,
      'type': type,
      'exceptionProductsCount': exceptionProductsCount,
    };
  }
}

class PromotionNomenclature {
  final int id;
  final bool inAction;
  final double price;
  final String currencyCode;
  final double planPrice;
  final int discount;
  final int planDiscount;

  PromotionNomenclature({
    required this.id,
    required this.inAction,
    required this.price,
    required this.currencyCode,
    required this.planPrice,
    required this.discount,
    required this.planDiscount,
  });

  factory PromotionNomenclature.fromJson(Map<String, dynamic> json) {
    return PromotionNomenclature(
      id: json['id'] as int,
      inAction: json['inAction'] as bool,
      price: (json['price'] as num).toDouble(),
      currencyCode: json['currencyCode'] as String,
      planPrice: (json['planPrice'] as num).toDouble(),
      discount: json['discount'] as int,
      planDiscount: json['planDiscount'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'inAction': inAction,
      'price': price,
      'currencyCode': currencyCode,
      'planPrice': planPrice,
      'discount': discount,
      'planDiscount': planDiscount,
    };
  }
}

================
File: entities/saved_product.dart
================
import 'package:hive/hive.dart';

part 'saved_product.g.dart';

@HiveType(typeId: 0)
class SavedProduct {
  @HiveField(0)
  final String productId;

  @HiveField(1)
  final String name;

  @HiveField(2)
  final String imageUrl;

  @HiveField(3)
  final String sellerId;

  @HiveField(4)
  final String sellerName;

  @HiveField(5)
  final String brandId;

  @HiveField(6)
  final String brandName;

  @HiveField(7)
  final String marketplaceType;

  SavedProduct({
    required this.productId,
    required this.name,
    required this.imageUrl,
    required this.sellerId,
    required this.sellerName,
    required this.brandId,
    required this.brandName,
    required this.marketplaceType,
  });
}

================
File: entities/saved_product.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'saved_product.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class SavedProductAdapter extends TypeAdapter<SavedProduct> {
  @override
  final int typeId = 0;

  @override
  SavedProduct read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return SavedProduct(
      productId: fields[0] as String,
      name: fields[1] as String,
      imageUrl: fields[2] as String,
      sellerId: fields[3] as String,
      sellerName: fields[4] as String,
      brandId: fields[5] as String,
      brandName: fields[6] as String,
      marketplaceType: fields[7] as String,
    );
  }

  @override
  void write(BinaryWriter writer, SavedProduct obj) {
    writer
      ..writeByte(8)
      ..writeByte(0)
      ..write(obj.productId)
      ..writeByte(1)
      ..write(obj.name)
      ..writeByte(2)
      ..write(obj.imageUrl)
      ..writeByte(3)
      ..write(obj.sellerId)
      ..writeByte(4)
      ..write(obj.sellerName)
      ..writeByte(5)
      ..write(obj.brandId)
      ..writeByte(6)
      ..write(obj.brandName)
      ..writeByte(7)
      ..write(obj.marketplaceType);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SavedProductAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

================
File: entities/sku.dart
================
class Sku {
  final String id;
  final String marketplaceType;
  final String sellerId;
  final String sellerName;
  final String brandId;
  final String brandName;

  Sku({
    required this.id,
    required this.marketplaceType,
    required this.sellerId,
    required this.sellerName,
    required this.brandId,
    required this.brandName,
  });

  factory Sku.fromJson(Map<String, dynamic> json) {
    return Sku(
      id: json['id']?.toString() ?? '',
      marketplaceType: json['marketplace_type']?.toString() ?? '',
      sellerId: json['seller_id']?.toString() ?? '',
      sellerName: json['seller_name']?.toString() ?? '',
      brandId: json['brand_id']?.toString() ?? '',
      brandName: json['brand_name']?.toString() ?? '',
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'marketplace_type': marketplaceType,
        'seller_id': sellerId,
        'seller_name': sellerName,
        'brand_id': brandId,
        'brand_name': brandName,
      };
}

================
File: entities/stock.dart
================
import 'package:mc_dashboard/domain/entities/warehouse.dart';

class Stock {
  final int productId;
  final int warehouseId;
  final int sizeOptionId;
  final int quantity;
  final int basicPrice;
  final DateTime timestamp;

  Stock({
    required this.productId,
    required this.warehouseId,
    required this.sizeOptionId,
    required this.quantity,
    required this.basicPrice,
    required this.timestamp,
  });

  factory Stock.fromJson(Map<String, dynamic> json) {
    int parseInt(dynamic value) {
      if (value is int) return value;
      if (value is String) return int.tryParse(value) ?? 0;
      return 0;
    }

    return Stock(
      productId: parseInt(json['product_id']),
      warehouseId: parseInt(json['warehouse_id']),
      sizeOptionId: parseInt(json['size_option_id']),
      quantity: parseInt(json['quantity']),
      basicPrice: parseInt(json['basic_price']),
      timestamp: json['timestamp'] != null && json['timestamp'] is String
          ? DateTime.tryParse(json['timestamp'] as String) ??
              DateTime.fromMillisecondsSinceEpoch(0)
          : DateTime.fromMillisecondsSinceEpoch(0),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'product_id': productId,
      'warehouse_id': warehouseId,
      'size_option_id': sizeOptionId,
      'quantity': quantity,
      'basic_price': basicPrice,
      'timestamp': timestamp.toIso8601String(),
    };
  }
}

(List<Map<String, dynamic>>, int) calculateWarehouseShares(
    List<Stock> stocks, List<Warehouse> warehouses) {
  DateTime latestDate = stocks
      .map((stock) => stock.timestamp)
      .reduce((a, b) => a.isAfter(b) ? a : b);

  final filteredStocks = stocks
      .where((stock) =>
          stock.timestamp.year == latestDate.year &&
          stock.timestamp.month == latestDate.month &&
          stock.timestamp.day == latestDate.day)
      .toList();

  final warehouseQuantities = <int, int>{};
  for (final stock in filteredStocks) {
    warehouseQuantities[stock.warehouseId] =
        (warehouseQuantities[stock.warehouseId] ?? 0) + stock.quantity;
  }

  final totalQuantity =
      warehouseQuantities.values.fold(0, (sum, qty) => sum + qty);

  final warehouseShares = warehouseQuantities.entries.map((entry) {
    final warehouseId = entry.key;
    final quantity = entry.value;

    final whNames = warehouses.where((element) => element.id == warehouseId);
    String whName = "";
    if (whNames.isNotEmpty) {
      whName = whNames.first.name;
    } else {
      whName = 'Склад $warehouseId';
    }

    return {
      "name": whName,
      "value": quantity,
    };
  }).toList();
  warehouseShares.sort((a, b) {
    final aValue = (a["value"] as num?) ?? 0;
    final bValue = (b["value"] as num?) ?? 0;

    return bValue.compareTo(aValue);
  });

  return (warehouseShares, totalQuantity);
}

Map<String, int> calculateDailyStockSums(List<Stock> stocks) {
  final dailySums = <String, int>{};

  for (final stock in stocks) {
    final dateKey = "${stock.timestamp.year.toString().padLeft(4, '0')}-"
        "${stock.timestamp.month.toString().padLeft(2, '0')}-"
        "${stock.timestamp.day.toString().padLeft(2, '0')}";

    dailySums[dateKey] = (dailySums[dateKey] ?? 0) + stock.quantity;
  }

  return dailySums;
}

================
File: entities/subject_summary_item.dart
================
import 'dart:convert';

class SubjectSummaryItem {
  final int subjectId;
  final String subjectName;
  final String? subjectParentName;
  final int totalRevenue;
  final int totalOrders;
  final int totalSkus;
  final int medianPrice;
  final int skusWithOrders;
  final String historyData;
  Map<String, dynamic> get decodedHistoryData => jsonDecode(historyData);
  SubjectSummaryItem({
    required this.subjectId,
    required this.subjectName,
    this.subjectParentName,
    required this.totalRevenue,
    required this.totalOrders,
    required this.totalSkus,
    required this.medianPrice,
    required this.skusWithOrders,
    required this.historyData,
  });

  factory SubjectSummaryItem.fromJson(Map<String, dynamic> json) {
    return SubjectSummaryItem(
      subjectId: json['subject_id'],
      subjectName: json['subject_name'],
      subjectParentName: json['subject_parent_name'],
      totalRevenue: json['total_revenue'],
      totalOrders: json['total_orders'],
      totalSkus: json['total_skus'],
      medianPrice: json['median_price'],
      skusWithOrders: json['skus_with_orders'],
      historyData: json['history_data'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'subject_id': subjectId,
      'subject_name': subjectName,
      'subject_parent_name': subjectParentName,
      'total_revenue': totalRevenue,
      'total_orders': totalOrders,
      'total_skus': totalSkus,
      'median_price': medianPrice,
      'skus_with_orders': skusWithOrders,
      'history_data': historyData,
    };
  }

  copyWith({
    int? subjectId,
    String? subjectName,
    String? subjectParentName,
    int? totalRevenue,
    int? totalOrders,
    int? totalSkus,
    int? medianPrice,
    int? skusWithOrders,
    String? historyData,
  }) {
    return SubjectSummaryItem(
      subjectId: subjectId ?? this.subjectId,
      subjectName: subjectName ?? this.subjectName,
      subjectParentName: subjectParentName ?? this.subjectParentName,
      totalRevenue: totalRevenue ?? this.totalRevenue,
      totalOrders: totalOrders ?? this.totalOrders,
      totalSkus: totalSkus ?? this.totalSkus,
      medianPrice: medianPrice ?? this.medianPrice,
      skusWithOrders: skusWithOrders ?? this.skusWithOrders,
      historyData: historyData ?? this.historyData,
    );
  }
}

================
File: entities/supplier_item.dart
================
class SupplierItem {
  final int id;
  final String name;

  SupplierItem({
    required this.id,
    required this.name,
  });

  factory SupplierItem.fromJson(Map<String, dynamic> json) {
    return SupplierItem(
      id: json['id'] as int,
      name: json['name'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
    };
  }
}

class SuppliersResponse {
  final List<SupplierItem> suppliers;

  SuppliersResponse({required this.suppliers});

  factory SuppliersResponse.fromJson(dynamic json) {
    // Поскольку сервер возвращает массив, проверяем тип json
    if (json is List) {
      return SuppliersResponse(
        suppliers: json
            .map((item) => SupplierItem.fromJson(item as Map<String, dynamic>))
            .toList(),
      );
    } else {
      throw Exception('Invalid response format: Expected a list');
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'suppliers': suppliers.map((item) => item.toJson()).toList(),
    };
  }
}

================
File: entities/token_info.dart
================
class TokenInfo {
  final String token;
  final String type;
  final String endDate;

  TokenInfo({
    required this.token,
    required this.type,
    required this.endDate,
  });
}

================
File: entities/user_email.dart
================
import 'package:hive/hive.dart';

part 'user_email.g.dart';

@HiveType(typeId: 2) // Уникальный ID для модели Hive
class UserEmail {
  @HiveField(0)
  final String email;

  UserEmail({required this.email});
}

================
File: entities/user_email.g.dart
================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_email.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class UserEmailAdapter extends TypeAdapter<UserEmail> {
  @override
  final int typeId = 2;

  @override
  UserEmail read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return UserEmail(
      email: fields[0] as String,
    );
  }

  @override
  void write(BinaryWriter writer, UserEmail obj) {
    writer
      ..writeByte(1)
      ..writeByte(0)
      ..write(obj.email);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserEmailAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

================
File: entities/warehouse.dart
================
class Warehouse {
  final int id;
  final String name;

  Warehouse({
    required this.id,
    required this.name,
  });

  factory Warehouse.fromJson(Map<String, dynamic> json) {
    return Warehouse(
      id: json['id'] as int,
      name: json['name'] as String,
    );
  }

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
      };
}

================
File: services/api_key_service.dart
================
import 'package:mc_dashboard/presentation/api_keys_screen/api_keys_view_model.dart';

abstract class ApiKeyServiceStorage {
  Future<void> saveApiToken(String keyName, String token);
  Future<String?> getApiToken(String keyName);
  Future<void> deleteApiToken(String keyName);
}

class ApiKeyService implements ApiKeyViewModelStorageService {
  ApiKeyService({required this.storage});
  final ApiKeyServiceStorage storage;

  @override
  Future<void> saveApiKey(String keyName, String token) async {
    await storage.saveApiToken(keyName, token);
  }

  @override
  Future<String?> getApiKey(String keyName) async {
    return await storage.getApiToken(keyName);
  }

  @override
  Future<void> deleteApiToken(String keyName) async {
    await storage.deleteApiToken(keyName);
  }
}

================
File: services/auth_service.dart
================
import 'dart:convert';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:fpdart/fpdart.dart';

import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';

import 'package:mc_dashboard/domain/entities/token_info.dart';

import 'package:mc_dashboard/presentation/login_screen/login_view_model.dart';
import 'package:mc_dashboard/presentation/mailing_screen/mailing_view_model.dart';
import 'package:mc_dashboard/presentation/mailing_screen/saved_key_phrases_view_model.dart';
import 'package:mc_dashboard/presentation/mailing_screen/saved_products_view_model.dart';
import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';
import 'package:mc_dashboard/presentation/seo_requests_extend_screen/seo_requests_extend_view_model.dart';
import 'package:mc_dashboard/presentation/subject_products_screen/subject_products_view_model.dart';
import 'package:mc_dashboard/presentation/subscription_screen/subscription_view_model.dart';

abstract class AuthServiceAuthApiClient {
  Future<Either<AppErrorBase, String>> register(
      String username, String password);
  Future<Either<AppErrorBase, String>> login(String username, String password);
}

abstract class AuthServiceStorage {
  Either<AppErrorBase, void> saveToken(String token);
  Either<AppErrorBase, String?> getToken();
  Either<AppErrorBase, void> clearToken();
}

class AuthService
    implements
        LoginViewModelAuthService,
        SavedProductsAuthService,
        SavedKeyPhrasesAuthService,
        SubscriptionAuthService,
        MailingAuthService,
        SeoRequestsExtendAuthService,
        SubjectProductsAuthService,
        ProductAuthService {
  final AuthServiceAuthApiClient apiClient;
  final AuthServiceStorage authServiceStorage;

  const AuthService(
      {required this.apiClient, required this.authServiceStorage});

  @override
  Future<Either<AppErrorBase, void>> register() async {
    final user = getFirebaseAuthUserInfo();
    if (user == null) {
      return left(AppErrorBase('User is null',
          name: 'register', sendTo: true, source: 'AuthService'));
    }
    final tokenEither = await apiClient.register(user.email!, user.uid);
    return tokenEither.fold(
      (error) => left(error),
      (token) => authServiceStorage.saveToken(token),
    );
  }

  @override
  Future<Either<AppErrorBase, void>> login() async {
    final user = getFirebaseAuthUserInfo();
    if (user == null) {
      return left(AppErrorBase('User is null',
          name: 'login', sendTo: true, source: 'AuthService'));
    }
    final tokenEither = await apiClient.login(user.email!, user.uid);
    return tokenEither.fold(
      (error) => left(error),
      (token) => authServiceStorage.saveToken(token),
    );
  }

  // Check if token is expired
  bool isTokenExpired(String token) {
    final parts = token.split('.');
    if (parts.length != 3) return true;

    final payload = json
        .decode(utf8.decode(base64Url.decode(base64Url.normalize(parts[1]))));
    final exp = payload['exp'] as int?;
    if (exp == null) return true;

    final now = DateTime.now().toUtc().millisecondsSinceEpoch ~/ 1000;
    return now >= exp;
  }

  // Get token and its type for use in the application
  @override
  Future<Either<AppErrorBase, TokenInfo>> getTokenInfo() async {
    // get token from storage
    final tokenEither = authServiceStorage.getToken();

    final token = tokenEither.fold((l) => null, (r) => r);
    // Token is not expired
    if (token != null && !isTokenExpired(token)) {
      final payload = getPayload(token);

      final userType = getTokenType(payload);
      final endDate = getEndDate(payload);
      if (userType == null || endDate == null) {
        return left(AppErrorBase(
            'Не удалось получить информацию о пользователе',
            name: 'getTokenAndType',
            sendTo: true,
            source: 'AuthService'));
      }
      return right(TokenInfo(token: token, type: userType, endDate: endDate));
    }

    // Token is expired
    // step 1 login
    await login();

    // step 2 try again
    final newTokenEither = authServiceStorage.getToken();
    final newToken = newTokenEither.fold((l) => null, (r) => r);
    if (newToken != null) {
      final newPayload = getPayload(newToken);

      final newUserType = getTokenType(newPayload);
      final newEndDate = getEndDate(newPayload);

      if (newUserType == null || newEndDate == null) {
        return left(AppErrorBase(
            'Не удалось получить информацию о пользователе',
            name: 'getTokenAndType',
            sendTo: true,
            source: 'AuthService'));
      }
      return right(
          TokenInfo(token: newToken, type: newUserType, endDate: newEndDate));
    } else {
      return left(AppErrorBase('Token not found in storage',
          name: 'getTokenAndType', sendTo: true, source: 'AuthService'));
    }
  }

  // Clear token from storage
  @override
  Future<Either<AppErrorBase, void>> logout() async {
    await FirebaseAuth.instance.signOut();
    return authServiceStorage.clearToken();
  }

  @override
  User? getFirebaseAuthUserInfo() {
    final user = FirebaseAuth.instance.currentUser;
    if (user != null && user.email != null) {
      return user;
    } else {
      return null;
    }
  }

  dynamic getPayload(String token) {
    try {
      // Separate token into 3 parts: Header, Payload, Signature
      final parts = token.split('.');
      if (parts.length != 3) return null;

      // Decode the payload
      final payload = json.decode(
        utf8.decode(base64Url.decode(base64Url.normalize(parts[1]))),
      );

      return payload;
    } catch (e) {
      return null;
    }
  }

  String? getEndDate(dynamic payload) {
    try {
      // Extract endDate
      final endDate = payload['endDate'];
      if (endDate is String) {
        return endDate;
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  // Get token type (free or premium)
  String? getTokenType(dynamic payload) {
    try {
      final scopes = payload['scopes'] as int? ?? 0;

      if ((scopes & 0x002) == 0x002) return "premium";
      if ((scopes & 0x001) == 0x001) return "free";
      return null;
    } catch (e) {
      return null;
    }
  }

  String simpleEncrypt(String email, String date) {
    final data = "$email|$date";

    String encoded = base64UrlEncode(utf8.encode(data));

    encoded = encoded.replaceAll('=', '');

    return encoded;
  }
}

================
File: services/detailed_orders_service.dart
================
import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/infrastructure/api/detailed_orders.dart';

import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/entities/detailed_order_item.dart';
import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';
import 'package:mc_dashboard/presentation/subject_products_screen/subject_products_view_model.dart';

class DetailedOrdersService
    implements
        SubjectProductsViewModelDetailedOrdersService,
        ProductViewModelDetailedOrdersService {
  final DetailedOrdersApiClient detailedOrdersApiClient;

  DetailedOrdersService({required this.detailedOrdersApiClient});
  @override
  Future<Either<AppErrorBase, List<DetailedOrderItem>>> fetchDetailedOrders({
    int? subjectId,
    int? productId,
    int? isFbs,
    String pageSize = '10000',
  }) async {
    try {
      final result = await detailedOrdersApiClient.getDetailedOrders(
        subjectId: subjectId,
        productId: productId,
        pageSize: pageSize,
        isFbs: isFbs,
      );

      return Right(result.detailedOrders);
    } on DioException catch (e, stackTrace) {
      // Подробная обработка ошибок Dio
      final responseMessage = e.response?.data?['message'] ?? e.message;
      final error = AppErrorBase(
        'DioException: $responseMessage',
        name: 'fetchDetailedOrders',
        sendTo: true,
        source: 'DetailedOrdersService',
        args: [
          'subjectId: $subjectId',
          'productId: $productId',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error); // Логируйте ошибку
      return Left(error);
    } catch (e, stackTrace) {
      // Обработка всех других ошибок
      final error = AppErrorBase(
        'Unexpected error: $e',
        name: 'fetchDetailedOrders',
        sendTo: true,
        source: 'DetailedOrdersService',
        args: [
          'subjectId: $subjectId',
          'productId: $productId',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }
}

================
File: services/kw_lemmas_service.dart
================
import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/infrastructure/api/kw_lemmas.dart';

import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/entities/kw_lemmas.dart';
import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';

class KwLemmaService implements ProductViewModelKwLemmaService {
  final KwLemmasApiClient apiClient;

  KwLemmaService(this.apiClient);

  @override
  Future<Either<AppErrorBase, List<KwLemmaItem>>> get(
      {required List<int> ids}) async {
    if (ids.isEmpty) {
      return Right([]);
    }
    try {
      final result = await apiClient.getKwLemmas(ids: ids);

      return Right(result.kwLemmas);
    } on DioException catch (e, stackTrace) {
      if (e.response?.statusCode == 404) {
        return const Right([]);
      }

      // final responseMessage = e.response?.data?['message'] ?? e.message;
      final error = AppErrorBase(
        'DioException: $e',
        name: 'get',
        sendTo: true,
        source: 'KwLemmaService',
        args: [
          'ids: $ids',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    } catch (e, stackTrace) {
      final error = AppErrorBase(
        'Unexpected error: $e',
        name: 'get',
        sendTo: true,
        source: 'KwLemmaService',
        args: [
          'productId: $ids',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }
}

================
File: services/lemmatize_service.dart
================
import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';

import 'package:mc_dashboard/infrastructure/api/lemmatize.dart';

import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';

import 'package:mc_dashboard/domain/entities/lemmatize.dart';
import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';

class LemmatizeService implements ProductViewModelLemmatizeService {
  final LemmatizeApiClient apiClient;

  LemmatizeService({required this.apiClient});

  @override
  Future<Either<AppErrorBase, LemmatizeResponse>> get(
      {required LemmatizeRequest req}) async {
    try {
      final result = await apiClient.lemmatize(req);

      return Right(result);
    } on DioException catch (e, stackTrace) {
      // final responseMessage = e.response?.data?['message'] ?? e.message;
      final error = AppErrorBase(
        'DioException: $e',
        name: 'get',
        sendTo: true,
        source: 'LemmatizeService',
        args: [
          'req: $req',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    } catch (e, stackTrace) {
      final error = AppErrorBase(
        'Unexpected error: $e',
        name: 'get',
        sendTo: true,
        source: 'LemmatizeService',
        args: [
          'req: $req',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }
}

================
File: services/normqueries_service.dart
================
import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/infrastructure/api/normqueries.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/entities/normquery.dart';
import 'package:mc_dashboard/domain/entities/normquery_product.dart';
import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';
import 'package:mc_dashboard/presentation/seo_requests_extend_screen/seo_requests_extend_view_model.dart';

class NormqueryService
    implements
        ProductViewModelNormqueryService,
        SeoRequestsExtendNormqueryService {
  final NormqueriesApiClient apiClient;

  NormqueryService(this.apiClient);

  @override
  Future<Either<AppErrorBase, List<NormqueryProduct>>> get(
      {required List<int> ids}) async {
    if (ids.isEmpty) {
      return Right([]);
    }
    try {
      final result = await apiClient.getNormqueriesProducts(ids: ids);

      return Right(result.normqueriesWithProducts);
    } on DioException catch (e, stackTrace) {
      if (e.response?.statusCode == 404) {
        return const Right([]);
      }

      // final responseMessage = e.response?.data?['message'] ?? e.message;
      final error = AppErrorBase(
        'DioException: $e',
        name: 'get',
        sendTo: true,
        source: 'NormqueryService',
        args: [
          'ids: $ids',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    } catch (e, stackTrace) {
      final error = AppErrorBase(
        'Unexpected error: $e',
        name: 'get',
        sendTo: true,
        source: 'NormqueryService',
        args: [
          'productId: $ids',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }

  @override
  Future<Either<AppErrorBase, List<Normquery>>> getUniqueNormqueries(
      {required List<int> ids}) async {
    if (ids.isEmpty) {
      return Right([]);
    }
    try {
      final result = await apiClient.getUniqueNormqueries(ids: ids);

      return Right(result.uniqueNormqueries);
    } on DioException catch (e, stackTrace) {
      // final responseMessage = e.response?.data?['message'] ?? e.message;
      final error = AppErrorBase(
        'DioException: $e',
        name: 'getUniqueNormqueries',
        sendTo: true,
        source: 'NormqueryService',
        args: [
          'ids: $ids',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    } catch (e, stackTrace) {
      final error = AppErrorBase(
        'Unexpected error: $e',
        name: 'getUniqueNormqueries',
        sendTo: true,
        source: 'NormqueryService',
        args: [
          'ids: $ids',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }
}

================
File: services/orders_service.dart
================
import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/infrastructure/api/orders.dart';

import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/entities/order.dart';

import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';

class OrderService implements ProductViewModelOrderService {
  final OrdersApiClient ordersApiClient;

  OrderService({required this.ordersApiClient});

  @override
  Future<Either<AppErrorBase, List<OrderWb>>> getOneMonthOrders({
    int? productId,
  }) async {
    try {
      final today = DateTime.now();
      final startDate = today.subtract(const Duration(days: 30));
      final endDate = today;

      final startDateStr = startDate.toIso8601String().substring(0, 10);
      final endDateStr = endDate.toIso8601String().substring(0, 10);

      final result = await ordersApiClient.getOrders(
        productId: productId,
        pageSize: 10000,
        startDate: startDateStr,
        endDate: endDateStr,
      );

      return Right(result.orders);
    } on DioException catch (e, stackTrace) {
      // Обработка 404 ошибки: возвращаем пустой список
      if (e.response?.statusCode == 404) {
        return const Right([]);
      }

      // Обработка остальных ошибок
      final responseMessage = e.response?.data?['message'] ?? e.message;
      final error = AppErrorBase(
        'DioException: $responseMessage',
        name: 'getOneMonthOrders',
        sendTo: true,
        source: 'OrderService',
        args: [
          'productId: $productId',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    } catch (e, stackTrace) {
      final error = AppErrorBase(
        'Unexpected error: $e',
        name: 'getOneMonthOrders',
        sendTo: true,
        source: 'OrderService',
        args: [
          'productId: $productId',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }
}

================
File: services/products_service.dart
================
import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/infrastructure/api/products.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';

import 'package:mc_dashboard/domain/entities/product_item.dart';

class ProductService {
  final ProductsApiClient productsApiClient;

  ProductService({required this.productsApiClient});

  Future<Either<AppErrorBase, List<ProductItem>>> getProducts({
    int? brandId,
    int? subjectId,
    int? supplierId,
    int page = 1,
    int pageSize = 100,
  }) async {
    try {
      final result = await productsApiClient.getProducts(
        brandId: brandId,
        subjectId: subjectId,
        supplierId: supplierId,
        page: page,
        pageSize: pageSize,
      );

      return Right(result.products);
    } on DioException catch (e, stackTrace) {
      if (e.response?.statusCode == 404) {
        return const Right([]);
      }

      // Обработка остальных ошибок
      final responseMessage = e.response?.data?['message'] ?? e.message;
      final error = AppErrorBase(
        'DioException: $responseMessage',
        name: 'getProducts',
        sendTo: true,
        source: 'ProductService',
        args: [
          'brandId: $brandId',
          'subjectId: $subjectId',
          'supplierId: $supplierId',
          'page: $page',
          'pageSize: $pageSize',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    } catch (e, stackTrace) {
      final error = AppErrorBase(
        'Unexpected error: $e',
        name: 'getProducts',
        sendTo: true,
        source: 'ProductService',
        args: [
          'brandId: $brandId',
          'subjectId: $subjectId',
          'supplierId: $supplierId',
          'page: $page',
          'pageSize: $pageSize',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }
}

================
File: services/promotion_service.dart
================
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/entities/promotions.dart';

abstract class PromotionsServiceApiClient {
  Future<List<Promotion>> fetchPromotions({
    required String token,
    required DateTime startDate,
    required DateTime endDate,
    required bool allPromo,
    int limit = 10,
    int offset = 0,
  });

  Future<PromotionDetails> fetchPromotionDetails({
    required String token,
    required List<int> promotionIds,
  });

  Future<List<PromotionNomenclature>> fetchPromotionNomenclatures({
    required String token,
    required int promotionId,
    required bool inAction,
    int limit = 10,
    int offset = 0,
  });
}

class PromotionsServiceImpl {
  final PromotionsServiceApiClient apiClient;

  PromotionsServiceImpl({required this.apiClient});

  @override
  Future<Either<AppErrorBase, List<Promotion>>> fetchPromotionsForUser({
    required String token,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final promotions = await apiClient.fetchPromotions(
        token: token,
        startDate: startDate,
        endDate: endDate,
        allPromo: false,
      );
      return right(promotions);
    } catch (e) {
      return left(AppErrorBase(
        'Ошибка получения списка акций: $e',
        name: 'fetchPromotionsForUser',
        sendTo: true,
      ));
    }
  }

  @override
  Future<Either<AppErrorBase, PromotionDetails>> getPromotionDetails({
    required String token,
    required List<int> promotionIds,
  }) async {
    try {
      final details = await apiClient.fetchPromotionDetails(
        token: token,
        promotionIds: promotionIds,
      );
      return right(details);
    } catch (e) {
      return left(AppErrorBase(
        'Ошибка получения деталей акции: $e',
        name: 'getPromotionDetails',
        sendTo: true,
      ));
    }
  }

  @override
  Future<Either<AppErrorBase, List<PromotionNomenclature>>>
      getPromotionEligibleProducts({
    required String token,
    required int promotionId,
  }) async {
    try {
      final products = await apiClient.fetchPromotionNomenclatures(
        token: token,
        promotionId: promotionId,
        inAction: false,
      );
      return right(products);
    } catch (e) {
      return left(AppErrorBase(
        'Ошибка получения списка товаров для акции: $e',
        name: 'getPromotionEligibleProducts',
        sendTo: true,
      ));
    }
  }
}

================
File: services/saved_key_phrases_service.dart
================
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/entities/key_phrase.dart';

import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';
import 'package:mc_dashboard/presentation/mailing_screen/saved_key_phrases_view_model.dart';

abstract class SavedKeyPhrasesRepository {
  Future<void> saveKeyPhrase(KeyPhrase keyPhrase);
  Future<void> deleteKeyPhrase(String phraseText);
  Future<List<KeyPhrase>> getAllKeyPhrases();
}

abstract class SavedKeyPhrasesApiClient {
  Future<List<KeyPhrase>> findUserSearchQueries({
    required String token,
  });
  Future<void> deleteUserSearchQueries({
    required String token,
    required List<KeyPhrase> phrases,
  });
  Future<void> saveUserSearchQueries({
    required String token,
    required List<KeyPhrase> phrases,
  });
}

class SavedKeyPhrasesService
    implements
        ProductViewModelSavedKeyPhrasesService,
        SavedKeyPhrasesKeyPhrasesService {
  SavedKeyPhrasesService({
    required this.savedKeyPhrasesRepo,
    required this.savedKeyPhrasesApiClient,
  });

  final SavedKeyPhrasesRepository savedKeyPhrasesRepo;
  final SavedKeyPhrasesApiClient savedKeyPhrasesApiClient;

  // Future<Either<AppErrorBase, void>> _syncKeyPhrases({
  //   required String token,
  //   required List<KeyPhrase> newPhrases,
  // }) async {
  //   try {
  //     final currentPhrases = await savedKeyPhrasesRepo.getAllKeyPhrases();

  //     // Фразы для добавления или обновления
  //     final addedOrUpdatedPhrases = newPhrases
  //         .where((phrase) =>
  //             !currentPhrases.any((p) => p.phraseText == phrase.phraseText))
  //         .toList();

  //     // Фразы для удаления
  //     final removedPhrases = currentPhrases
  //         .where((phrase) =>
  //             !newPhrases.any((p) => p.phraseText == phrase.phraseText))
  //         .toList();

  //     if (addedOrUpdatedPhrases.isNotEmpty) {
  //       final saveResult = await _saveKeyPhrases(
  //         token: token,
  //         phrases: addedOrUpdatedPhrases,
  //       );
  //       if (saveResult.isLeft()) {
  //         return saveResult;
  //       }
  //     }

  //     if (removedPhrases.isNotEmpty) {
  //       final deleteResult = await deleteKeyPhrases(
  //         token: token,
  //         phrases: removedPhrases,
  //       );
  //       if (deleteResult.isLeft()) {
  //         return deleteResult;
  //       }
  //     }
  //     return right(null);
  //   } catch (e) {
  //     return left(AppErrorBase(
  //       'Caught error: $e',
  //       name: 'syncKeyPhrases',
  //       sendTo: true,
  //       source: 'SavedKeyPhrasesService',
  //     ));
  //   }
  // }

  /// Сохранение новых ключевых фраз на сервере и локально
  // Future<Either<AppErrorBase, void>> _saveKeyPhrases({
  //   required String token,
  //   required List<KeyPhrase> phrases,
  // }) async {
  //   try {
  //     await savedKeyPhrasesApiClient.saveUserSearchQueries(
  //       token: token,
  //       phrases: phrases,
  //     );
  //     for (final phrase in phrases) {
  //       await savedKeyPhrasesRepo.saveKeyPhrase(phrase);
  //     }
  //     return right(null);
  //   } catch (e) {
  //     return left(AppErrorBase(
  //       'Caught error: $e',
  //       name: '_saveKeyPhrases',
  //       sendTo: true,
  //       source: 'SavedKeyPhrasesService',
  //     ));
  //   }
  // }

  @override
  Future<Either<AppErrorBase, void>> deleteKeyPhrases({
    required String token,
    required List<KeyPhrase> phrases,
  }) async {
    try {
      // Server
      await savedKeyPhrasesApiClient.deleteUserSearchQueries(
        token: token,
        phrases: phrases,
      );

      // Local
      for (final phrase in phrases) {
        await savedKeyPhrasesRepo.deleteKeyPhrase(phrase.phraseText);
      }
      return right(null);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: '_deleteKeyPhrases',
        sendTo: true,
        source: 'SavedKeyPhrasesService',
      ));
    }
  }

  @override
  Future<Either<AppErrorBase, List<KeyPhrase>>> getKeyPhrases({
    required String token,
  }) async {
    try {
      // Server
      final serverPhrases =
          await savedKeyPhrasesApiClient.findUserSearchQueries(
        token: token,
      );

      // Local
      final localPhrases = await savedKeyPhrasesRepo.getAllKeyPhrases();
      bool localStorageUpdated = false;

      // Add or update
      for (final phrase in serverPhrases) {
        if (!localPhrases.any((p) => p.phraseText == phrase.phraseText)) {
          await savedKeyPhrasesRepo.saveKeyPhrase(phrase);
          localStorageUpdated = true;
        }
      }

      // Delete
      for (final phrase in localPhrases) {
        if (!serverPhrases.any((p) => p.phraseText == phrase.phraseText)) {
          await savedKeyPhrasesRepo.deleteKeyPhrase(phrase.phraseText);
          localStorageUpdated = true;
        }
      }

      // Update
      final updatedPhrases = localStorageUpdated
          ? await savedKeyPhrasesRepo.getAllKeyPhrases()
          : localPhrases;

      return right(updatedPhrases);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'getKeyPhrases',
        sendTo: true,
        source: 'SavedKeyPhrasesService',
      ));
    }
  }

  @override
  Future<Either<AppErrorBase, void>> addPhrases({
    required String token,
    required List<KeyPhrase> phrases,
  }) async {
    try {
      await savedKeyPhrasesApiClient.saveUserSearchQueries(
        token: token,
        phrases: phrases,
      );

      final localPhrases = await savedKeyPhrasesRepo.getAllKeyPhrases();
      for (final phrase in phrases) {
        if (localPhrases.any((p) => p.phraseText == phrase.phraseText)) {
          continue;
        }
        await savedKeyPhrasesRepo.saveKeyPhrase(phrase);
      }

      return right(null);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'addPhrases',
        sendTo: true,
        source: 'SavedKeyPhrasesService',
      ));
    }
  }
}

================
File: services/saved_products_service.dart
================
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/core/utils/basket_num.dart';

import 'package:mc_dashboard/domain/entities/saved_product.dart';
import 'package:mc_dashboard/domain/entities/sku.dart';

import 'package:mc_dashboard/presentation/mailing_screen/saved_products_view_model.dart';
import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';
import 'package:mc_dashboard/presentation/subject_products_screen/subject_products_view_model.dart';

abstract class SavedProductsRepository {
  Future<void> saveProduct(SavedProduct products);
  Future<List<SavedProduct>> loadProducts();
  Future<void> deleteProduct(String productId);
}

abstract class SavedProductsApiClient {
  Future<List<Sku>> findUserSkus({
    required String token,
  });
  Future<void> saveUserSkus({
    required String token,
    required List<Sku> skus,
  });
  Future<void> deleteUserSkus({
    required String token,
    required List<Sku> skus,
  });
}

class SavedProductsService
    implements
        SubjectProductsSavedProductsService,
        ProductViewModelSavedProductsService,
        SavedProductsSavedProductsService {
  SavedProductsService({
    required this.savedProductsRepo,
    required this.savedProductsApiClient,
    // required this.suppliersApiClient,
  });

  final SavedProductsRepository savedProductsRepo;
  final SavedProductsApiClient savedProductsApiClient;
  // final SuppliersApiClient suppliersApiClient;

  /// Синхронизация сохранённых товаров
  @override
  Future<Either<AppErrorBase, void>> syncSavedProducts({
    required String token,
    required List<SavedProduct> products,
  }) async {
    try {
      // get local saved products
      final currentProducts = await savedProductsRepo.loadProducts();
      final currentSkus =
          currentProducts.map((product) => product.productId).toList();

      // get products to add
      final addedSkus = products
          .where((sku) => !currentSkus.contains(sku.productId))
          .toList();

      // get products to delete
      final removedSkus = currentSkus
          .where((skuId) => !products.any((sku) => sku.productId == skuId))
          .toList();

      // Save new
      if (addedSkus.isNotEmpty) {
        final saveResult =
            await _saveUserProducts(token: token, products: addedSkus);
        if (saveResult.isLeft()) {
          return saveResult;
        }
      }

      // Delete missing
      if (removedSkus.isNotEmpty) {
        final productsToRemove = currentProducts
            .where((product) => removedSkus.contains(product.productId))
            .toList();
        final deleteResult = await _deleteUserSkus(
            token: token,
            skus: productsToRemove
                .map((product) => Sku(
                    id: product.productId,
                    marketplaceType: product.marketplaceType,
                    sellerId: product.sellerId.toString(),
                    sellerName: product.sellerName,
                    brandId: product.brandId.toString(),
                    brandName: product.brandName))
                .toList());
        if (deleteResult.isLeft()) {
          return deleteResult;
        }
      }

      return right(null);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'syncSavedProducts',
        sendTo: true,
        source: 'SavedProductsService',
      ));
    }
  }

  @override
  Future<Either<AppErrorBase, void>> addProducts({
    required String token,
    required List<SavedProduct> products,
  }) async {
    // Save on server
    try {
      final skus = products.map((product) => Sku(
            id: product.productId.toString(),
            marketplaceType: product.marketplaceType,
            sellerId: product.sellerId.toString(),
            sellerName: product.sellerName,
            brandId: product.brandId.toString(),
            brandName: product.brandName,
          ));
      await savedProductsApiClient.saveUserSkus(
        token: token,
        skus: skus.toList(),
      );
      // get local saved products
      final currentProducts = await savedProductsRepo.loadProducts();
      final currentSkus =
          currentProducts.map((product) => product.productId).toList();

      // get products to add
      final addedSkus = products
          .where((sku) => !currentSkus.contains(sku.productId))
          .toList();

      // Save new
      if (addedSkus.isNotEmpty) {
        final saveResult =
            await _saveUserProducts(token: token, products: addedSkus);
        if (saveResult.isLeft()) {
          return saveResult;
        }
      }
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'addProducts',
        sendTo: true,
        source: 'SavedProductsService',
      ));
    }
    return right(null);
  }

  Future<Either<AppErrorBase, void>> _saveUserProducts({
    required String token,
    required List<SavedProduct> products,
  }) async {
    try {
      // Save on server
      final skus = products.map((product) => Sku(
            id: product.productId.toString(),
            marketplaceType: product.marketplaceType,
            sellerId: product.sellerId.toString(),
            sellerName: product.sellerName,
            brandId: product.brandId.toString(),
            brandName: product.brandName,
          ));
      await savedProductsApiClient.saveUserSkus(
        token: token,
        skus: skus.toList(),
      );

      // Save on local
      for (final sku in products) {
        await savedProductsRepo.saveProduct(sku);
      }
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: '_saveUserSkus',
        sendTo: true,
        source: 'SavedProductsService',
      ));
    }
    return right(null);
  }

  Future<Either<AppErrorBase, void>> _deleteUserSkus({
    required String token,
    required List<Sku> skus,
  }) async {
    try {
      // Delete on server
      final skusToDelete = skus
          .map((sku) => Sku(
              id: sku.id,
              marketplaceType: sku.marketplaceType,
              sellerId: sku.sellerId,
              sellerName: sku.sellerName,
              brandId: sku.brandId,
              brandName: sku.brandName))
          .toList();

      await savedProductsApiClient.deleteUserSkus(
        token: token,
        skus: skusToDelete,
      );

      // Delete on local
      for (final sku in skus) {
        await savedProductsRepo.deleteProduct(sku.id);
      }
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: '_deleteUserSkus',
        sendTo: true,
        source: 'SavedProductsService',
      ));
    }
    return right(null);
  }

  @override
  Future<Either<AppErrorBase, List<SavedProduct>>> getAllSavedProducts({
    required String token,
  }) async {
    try {
      // Get from server
      final serverSkus =
          await savedProductsApiClient.findUserSkus(token: token);
      // Get from local
      final localProducts = await savedProductsRepo.loadProducts();
      final localSkuIds =
          localProducts.map((product) => product.productId).toList();

      // Add new products to local

      Map<String, String> marketplaceTypesMap = {};
      bool localStorageUpdated = false;
      // Get missing products and fetch card info for them
      for (final sku in serverSkus) {
        if (!localSkuIds.contains(sku.id)) {
          marketplaceTypesMap[sku.id] = sku.marketplaceType;
          final id = int.tryParse(sku.id);
          if (id == null || sku.marketplaceType != "wb") {
            final product = SavedProduct(
              productId: sku.id,
              name: "",
              imageUrl: '',
              sellerId: sku.sellerId,
              sellerName: sku.sellerName,
              brandId: sku.brandId,
              brandName: sku.brandName,
              marketplaceType: sku.marketplaceType,
            );
            await savedProductsRepo.saveProduct(product);
            localStorageUpdated = true;
            continue;
          }

          final basketNum = getBasketNum(id);
          final imageUrl = calculateImageUrl(basketNum, id);

          final cardUrl = calculateCardUrl(imageUrl);
          final cardInfo = await fetchCardInfo(cardUrl);

          final product = SavedProduct(
            productId: sku.id,
            name: cardInfo.imtName,
            imageUrl: imageUrl,
            sellerId: sku.sellerId,
            sellerName: sku.sellerName,
            brandId: sku.brandId,
            brandName: sku.brandName,
            marketplaceType: sku.marketplaceType,
          );
          await savedProductsRepo.saveProduct(product);
          localStorageUpdated = true;
        }
      }

      // Delete deleted products
      for (final product in localProducts) {
        if (!serverSkus.any((sku) => sku.id == product.productId)) {
          await savedProductsRepo.deleteProduct(product.productId);
          localStorageUpdated = true;
        }
      }

      // Обновление локальных данных, если были изменения
      final updatedProducts = localStorageUpdated
          ? await savedProductsRepo.loadProducts()
          : localProducts;

      return right(updatedProducts);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'getAllSavedProducts',
        sendTo: true,
        source: 'SavedProductsService',
      ));
    }
  }

  // Future<Either<AppErrorBase, List<SupplierItem>>> getSuppliers({
  //   required List<int> supplierIds,
  // }) async {
  //   try {
  //     final response = await suppliersApiClient.getSuppliers(
  //       supplierIds: supplierIds.join(','),
  //     );
  //     return Right(response);
  //   } catch (e, stackTrace) {
  //     final error = AppErrorBase(
  //       'Unexpected error: $e',
  //       name: 'getSuppliers',
  //       sendTo: true,
  //       source: 'SuppliersService',
  //       args: [
  //         'supplierIds: $supplierIds',
  //       ],
  //       stackTrace: stackTrace.toString(),
  //     );
  //     AppLogger.log(error);
  //     return Left(error);
  //   }
  // }
}

================
File: services/stocks_service.dart
================
import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';

import 'package:mc_dashboard/infrastructure/api/stocks.dart';

import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';

import 'package:mc_dashboard/domain/entities/stock.dart';
import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';

class StocksService implements ProductViewModelStocksService {
  final StocksApiClient stocksApiClient;

  StocksService({required this.stocksApiClient});

  @override
  @override
  Future<Either<AppErrorBase, List<Stock>>> getMonthStocks({
    int? productId,
  }) async {
    try {
      final today = DateTime.now();
      final startDate = today.subtract(const Duration(days: 31));
      final endDate = today.subtract(const Duration(days: 1));

      final startDateStr = startDate.toIso8601String().substring(0, 10);
      final endDateStr = endDate.toIso8601String().substring(0, 10);

      final result = await stocksApiClient.getStocks(
        productId: productId,
        pageSize: 10000,
        startDate: startDateStr,
        endDate: endDateStr,
      );

      return Right(result.stocks);
    } on DioException catch (e, stackTrace) {
      if (e.response?.statusCode == 404) {
        return const Right([]);
      }

      if (e.response?.data == null) {
        final error = AppErrorBase(
          'DioException: ',
          name: 'getOneMonthStocks',
          sendTo: true,
          source: 'StocksService',
          args: [
            'productId: $productId',
          ],
          stackTrace: stackTrace.toString(),
        );
        AppLogger.log(error);
        return Left(error);
      }

      final responseMessage = e.response?.data?['message'] ?? e.message;
      final error = AppErrorBase(
        'DioException: $responseMessage',
        name: 'getOneMonthStocks',
        sendTo: true,
        source: 'StocksService',
        args: [
          'productId: $productId',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    } catch (e, stackTrace) {
      final error = AppErrorBase(
        'Unexpected error: $e',
        name: 'getOneMonthStocks',
        sendTo: true,
        source: 'StocksService',
        args: [
          'productId: $productId',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }
}

================
File: services/subjects_summary_service.dart
================
import 'dart:async';

import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/infrastructure/api/subjects_summary.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/entities/subject_summary_item.dart';
import 'package:mc_dashboard/presentation/choosing_niche_screen/choosing_niche_view_model.dart';
import 'package:mc_dashboard/presentation/empty_subjects_screen/empty_subjects_view_model.dart';
import 'package:mc_dashboard/presentation/subject_products_screen/subject_products_view_model.dart';

class SubjectsSummaryService
    implements
        SubjectProductsSubjectSummaryService,
        ChoosingNicheViewModelSubjectsSummaryService,
        EmptySubjectViewModelSubjectsSummaryService {
  final SubjectsSummaryApiClient subjectsSummaryApiClient;

  static final SubjectsSummaryService instance = SubjectsSummaryService._();

  // Why singleton? This is a workaround . Because we need to fetch subjects summary only once
  // despite it is used in multiple screens simultaneously when app is loading
  // (choose niche, subject products, empty subjects)
  SubjectsSummaryService._()
      : subjectsSummaryApiClient = SubjectsSummaryApiClient(Dio());

  Completer<Either<AppErrorBase, List<SubjectSummaryItem>>>?
      _fetchSubjectsCompleter;

  @override
  Future<Either<AppErrorBase, List<SubjectSummaryItem>>> fetchSubjectsSummary(
      [int? subjectId]) async {
    try {
      if (_fetchSubjectsCompleter != null &&
          !_fetchSubjectsCompleter!.isCompleted) {
        return _fetchSubjectsCompleter!.future;
      }
      _fetchSubjectsCompleter =
          Completer<Either<AppErrorBase, List<SubjectSummaryItem>>>();

      final rawJsonMapList = await subjectsSummaryApiClient
          .getSubjectsSummaryAsDynamic(subjectId: subjectId);
      final parsedList = await compute(_parseSubjectsList, rawJsonMapList);

      //
      _fetchSubjectsCompleter!.complete(right(parsedList));
      return Right(parsedList);
    } on DioException catch (e, stackTrace) {
      final message = e.response?.data['error'] ??
          "Unknown error occurred while fetching subjects summary";
      final error = AppErrorBase(
        message,
        name: "fetchSubjectsSummary",
        sendTo: true,
        source: "SubjectsSummaryService",
        args: [],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    } catch (e, stackTrace) {
      final error = AppErrorBase(
        "Unexpected error: $e",
        name: "fetchSubjectsSummary",
        sendTo: true,
        source: "ApiHandler",
        args: [],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }

  List<SubjectSummaryItem> _parseSubjectsList(List<dynamic> rawList) {
    return rawList.map((jsonItem) {
      return SubjectSummaryItem.fromJson(jsonItem.data as Map<String, dynamic>);
    }).toList();
  }
}

================
File: services/suppliers_service.dart
================
// import 'package:fpdart/fpdart.dart';
// import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
// import 'package:mc_dashboard/domain/entities/supplier_item.dart';
// import 'package:mc_dashboard/infrastructure/api/suppliers_api_client.dart';

// class SuppliersService {
//   final SuppliersApiClient suppliersApiClient;

//   SuppliersService({
//     required this.suppliersApiClient,
//   });

//   Future<Either<AppErrorBase, List<SupplierItem>>> getSuppliers({
//     required List<int> supplierIds,
//   }) async {
//     try {
//       final response = await suppliersApiClient.getSuppliers(
//         supplierIds: supplierIds,
//       );
//       return Right(response.suppliers);
//     } catch (e, stackTrace) {
//       final error = AppErrorBase(
//         'Unexpected error: $e',
//         name: 'getSuppliers',
//         sendTo: true,
//         source: 'SuppliersService',
//         args: [
//           'supplierIds: $supplierIds',
//         ],
//         stackTrace: stackTrace.toString(),
//       );
//       AppLogger.log(error);
//       return Left(error);
//     }
//   }
// }

================
File: services/tinkoff_payment_service.dart
================
import "dart:convert";

// ignore: depend_on_referenced_packages
import "package:http/http.dart" as http;
import "package:mc_dashboard/.env.dart";

import 'package:intl/intl.dart';
import "package:mc_dashboard/presentation/subscription_screen/subscription_view_model.dart";

class TinkoffPaymentService implements SubscriptionTinkoffPaymentService {
  @override
  Future<String?> processPayment(
      int amount, DateTime endDate, String email) async {
    // if prolongation subscription

    final orderNumber = DateTime.now().millisecond;

    final amountInKopeks = amount * 100;
    final description =
        'Оплата подписки до ${endDate.day}.${endDate.month}.${endDate.year}.'; // Ваше описание

    String formattedEndDate = DateFormat('yyyy-MM-dd').format(endDate);
    final response = await http.post(
      Uri.parse(
          '${McAuthService.baseUrl}/t_payment_link'), // Замените на ваш URL
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'amount': amountInKopeks,
        'email': email,
        'orderNumber': orderNumber,
        'description': description,
        'endDate': formattedEndDate,
        'receipt': {
          'Email': "ipbogachenko@yandex.ru",
          'Taxation': 'usn_income',
          'Items': [
            {
              'Name': 'Подписка marketconnect',
              'Price': amountInKopeks,
              'Quantity': 1.0,
              'Amount': amountInKopeks,
              "PaymentMethod": "full_payment",
              "PaymentObject": "service",
              "Tax": "none"
            },
          ],
        },
      }),
    );

    if (response.statusCode == 200) {
      return response.body;
    }
    return null;
  }
}

================
File: services/user_emails_service.dart
================
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/infrastructure/api/user_emails_api.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/entities/user_email.dart';

import 'package:mc_dashboard/presentation/mailing_screen/mailing_view_model.dart';

abstract class UserEmailsRepoRepository {
  Future<void> saveUserEmail(UserEmail userEmail);
  Future<void> deleteUserEmail(String email);
  Future<List<UserEmail>> getAllUserEmails();
}

abstract class UserEmailsServiceApiClient {
  Future<UserEmailsResponse> findUserEmails({required String token});
  Future<void> saveUserEmails(
      {required String token, required SaveEmailsRequest request});
  Future<void> deleteUserEmails(
      {required String token, required DeleteEmailsRequest request});
}

class UserEmailsService implements MailingUserEmailsService {
  UserEmailsService({
    required this.userEmailsRepoRepo,
    required this.userEmailsApiClient,
  });

  final UserEmailsServiceApiClient userEmailsApiClient;
  final UserEmailsRepoRepository userEmailsRepoRepo;

  @override
  Future<Either<AppErrorBase, void>> syncUserEmails({
    required String token,
    required List<String> newEmails,
  }) async {
    try {
      // Get current emails
      final currentEmails = (await userEmailsRepoRepo.getAllUserEmails())
          .map((e) => e.email)
          .toList();

      // Find added emails
      final addedEmails =
          newEmails.where((email) => !currentEmails.contains(email)).toList();

      // Find removed emails
      final removedEmails =
          currentEmails.where((email) => !newEmails.contains(email)).toList();

      // Save
      if (addedEmails.isNotEmpty) {
        final saveResult =
            await _saveUserEmails(token: token, emails: addedEmails);
        if (saveResult.isLeft()) {
          return saveResult;
        }
      }

      // Delete
      if (removedEmails.isNotEmpty) {
        final deleteResult =
            await _deleteUserEmail(token: token, emails: removedEmails);
        if (deleteResult.isLeft()) {
          return deleteResult;
        }
      }

      return right(null);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'syncUserEmails',
        sendTo: true,
        source: 'UserEmailsService',
      ));
    }
  }

  Future<Either<AppErrorBase, void>> _saveUserEmails(
      {required String token, required List<String> emails}) async {
    try {
      // Save on server
      await userEmailsApiClient.saveUserEmails(
        token: token,
        request: SaveEmailsRequest(emails: emails),
      );

      // Save locally
      for (final email in emails) {
        final userEmail = UserEmail(email: email);

        await userEmailsRepoRepo.saveUserEmail(userEmail);
      }
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'saveUserEmail',
        sendTo: true,
        source: 'UserEmailsService',
      ));
    }
    return right(null);
  }

  Future<Either<AppErrorBase, void>> _deleteUserEmail(
      {required String token, required List<String> emails}) async {
    try {
      // delete on server
      await userEmailsApiClient.deleteUserEmails(
        token: token,
        request: DeleteEmailsRequest(emails: emails),
      );

      // delete locally
      for (final email in emails) {
        await userEmailsRepoRepo.deleteUserEmail(email);
      }
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'deleteUserEmail',
        sendTo: true,
        source: 'UserEmailsService',
      ));
    }
    return right(null);
  }

  @override
  Future<Either<AppErrorBase, List<String>>> getAllUserEmails(
      {required String token}) async {
    try {
      // get from server
      final userEmailsFromServer = await userEmailsApiClient.findUserEmails(
        token: token,
      );

      // get locally
      final userEmails = await userEmailsRepoRepo.getAllUserEmails();
      List<String> emailsFromLocal =
          userEmails.map((userEmail) => userEmail.email).toList();

      // compare
      bool localStorageUpdated = false;
      for (var email in userEmailsFromServer.emails) {
        if (!emailsFromLocal.contains(email)) {
          // Save locally
          final missedUserEmail = UserEmail(email: email);

          await userEmailsRepoRepo.saveUserEmail(missedUserEmail);
          localStorageUpdated = true;
        }
      }

      // Delete locally
      for (final email in emailsFromLocal) {
        if (!userEmailsFromServer.emails.contains(email)) {
          await userEmailsRepoRepo.deleteUserEmail(email);
          localStorageUpdated = true;
        }
      }

      // get updated list
      if (localStorageUpdated) {
        final updatedUserEmails = await userEmailsRepoRepo.getAllUserEmails();
        emailsFromLocal =
            updatedUserEmails.map((userEmail) => userEmail.email).toList();
      }

      return right(emailsFromLocal);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'getAllUserEmails',
        sendTo: true,
        source: 'UserEmailsService',
      ));
    }
  }
}

================
File: services/user_sub_settings_service.dart
================
import 'package:fpdart/fpdart.dart';
import 'package:mc_dashboard/domain/entities/mailing_settings.dart';

import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';

import 'package:mc_dashboard/presentation/mailing_screen/mailing_view_model.dart';

abstract class UserSubSettingsRepoRepository {
  Future<void> saveSettings(Map<String, dynamic> newSettings);
  Future<Map<String, dynamic>> getSettings();
  Future<void> deleteSetting(String key);
}

abstract class UserSubSettingsApiClient {
  Future<List<Setting>> findUserSettings({
    required String token,
  });
  Future<void> saveUserSettings({
    required String token,
    required List<Setting> settings,
  });
  Future<void> deleteUserSettings({
    required String token,
    required List<Setting> settings,
  });
}

class UserSubSettingsService implements MailingSettingsMailingSettingsService {
  UserSubSettingsService({
    required this.mailingSettingsRepo,
    required this.userSettingsApiClient,
  });

  final UserSubSettingsRepoRepository mailingSettingsRepo;
  final UserSubSettingsApiClient userSettingsApiClient;

  @override
  Future<Either<AppErrorBase, void>> syncSettings({
    required String token,
    required Map<String, dynamic> newSettings,
  }) async {
    try {
      // Получение текущих настроек из локального хранилища
      final currentSettings = await mailingSettingsRepo.getSettings();

      // Найти добавленные или обновленные настройки
      final addedOrUpdatedSettings = newSettings.entries
          .where((entry) =>
              !currentSettings.containsKey(entry.key) ||
              currentSettings[entry.key] != entry.value)
          .toList();

      // Найти удаленные настройки
      final removedSettings = currentSettings.keys
          .where((key) => !newSettings.containsKey(key))
          .toList();

      // Сохранение добавленных или обновленных настроек
      if (addedOrUpdatedSettings.isNotEmpty) {
        final saveResult = await _saveSettings(
          token: token,
          settings: Map.fromEntries(addedOrUpdatedSettings),
        );
        if (saveResult.isLeft()) {
          return saveResult;
        }
      }

      // Удаление настроек
      if (removedSettings.isNotEmpty) {
        final deleteResult = await _deleteSettings(
          token: token,
          keys: removedSettings,
        );
        if (deleteResult.isLeft()) {
          return deleteResult;
        }
      }

      return right(null);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'syncSettings',
        sendTo: true,
        source: 'MailingSettingsService',
        stackTrace: e.toString(),
      ));
    }
  }

  Future<Either<AppErrorBase, void>> _saveSettings({
    required String token,
    required Map<String, dynamic> settings,
  }) async {
    try {
      // Преобразование в формат API
      final settingsJson = settings.entries
          .map((e) => Setting(key: e.key, value: e.value.toString()))
          .toList();

      // Сохранение на сервере
      await userSettingsApiClient.saveUserSettings(
        token: token,
        settings: settingsJson,
      );

      // Сохранение локально
      await mailingSettingsRepo.saveSettings(settings);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: '_saveSettings',
        sendTo: true,
        source: 'MailingSettingsService',
      ));
    }
    return right(null);
  }

  Future<Either<AppErrorBase, void>> _deleteSettings({
    required String token,
    required List<String> keys,
  }) async {
    try {
      // Преобразование в формат API
      final settingsJson =
          keys.map((key) => Setting(key: key, value: '')).toList();

      // Удаление на сервере
      await userSettingsApiClient.deleteUserSettings(
        token: token,
        settings: settingsJson,
      );

      // Удаление локально
      for (final key in keys) {
        await mailingSettingsRepo.deleteSetting(key);
      }
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: '_deleteSettings',
        sendTo: true,
        source: 'MailingSettingsService',
      ));
    }
    return right(null);
  }

  @override
  Future<Either<AppErrorBase, Map<String, dynamic>>> getSettings({
    required String token,
  }) async {
    try {
      // Получение настроек с сервера
      final serverSettingsResponse =
          await userSettingsApiClient.findUserSettings(token: token);
      final serverSettings = {
        for (var setting in serverSettingsResponse) setting.key: setting.value,
      };

      // Получение локальных настроек
      final localSettings = await mailingSettingsRepo.getSettings();

      bool localStorageUpdated = false;

      // Синхронизация добавленных или измененных настроек
      for (final entry in serverSettings.entries) {
        if (!localSettings.containsKey(entry.key) ||
            localSettings[entry.key] != entry.value) {
          await mailingSettingsRepo.saveSettings({entry.key: entry.value});
          localStorageUpdated = true;
        }
      }

      // Удаление локальных настроек, отсутствующих на сервере
      for (final key in localSettings.keys) {
        if (!serverSettings.containsKey(key)) {
          await mailingSettingsRepo.deleteSetting(key);
          localStorageUpdated = true;
        }
      }

      // Получение актуализированных настроек
      final updatedSettings = localStorageUpdated
          ? await mailingSettingsRepo.getSettings()
          : localSettings;

      return right(updatedSettings);
    } catch (e) {
      return left(AppErrorBase(
        'Caught error: $e',
        name: 'getSettings',
        sendTo: true,
        source: 'MailingSettingsService',
        stackTrace: e.toString(),
      ));
    }
  }
}

================
File: services/warehouses_service.dart
================
import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';

import 'package:mc_dashboard/infrastructure/api/warehouses.dart';
import 'package:mc_dashboard/core/base_classes/app_error_base_class.dart';
import 'package:mc_dashboard/domain/entities/warehouse.dart';
import 'package:mc_dashboard/presentation/product_screen/product_view_model.dart';

class WhService implements ProductViewModelWhService {
  final WarehousesApiClient whApiClient;

  WhService({required this.whApiClient});

  @override
  Future<Either<AppErrorBase, List<Warehouse>>> getWarehouses({
    required List<int> ids,
  }) async {
    try {
      final result = await whApiClient.getWarehouses(ids: ids);

      return Right(result.warehouses);
    } on DioException catch (e, stackTrace) {
      final responseMessage = e.response?.data?['message'] ?? e.message;
      final error = AppErrorBase(
        'DioException: $responseMessage',
        name: 'getOneMonthStocks',
        sendTo: true,
        source: 'WhService',
        args: [
          'productId: $ids',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    } catch (e, stackTrace) {
      final error = AppErrorBase(
        'Unexpected error: $e',
        name: 'getOneMonthStocks',
        sendTo: true,
        source: 'WhService',
        args: [
          'productId: $ids',
        ],
        stackTrace: stackTrace.toString(),
      );
      AppLogger.log(error);
      return Left(error);
    }
  }
}



================================================================
End of Codebase
================================================================
